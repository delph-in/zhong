;;; -*- Mode: TDL; Coding: utf-8 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Lexical Types of the Chinese Languages
;;; created at:
;;;     Fri Oct 31 2014
;;; created by Sanghoun Song (SSH) and 
;;;            Zhenzhen Fan (ZZF)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

animate-lex-item := lex-item & 
 [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.ANIMACY animate ]. 
human-lex-item := lex-item & 
 [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.ANIMACY human ]. 
non-human-lex-item := lex-item & 
 [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.ANIMACY non-human ]. 
inanimate-lex-item := lex-item & 
 [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.ANIMACY inanimate ]. 

loc-lex-item := lex-item & 
 [ SYNSEM.LOCAL.CAT.HEAD.LOC + ]. 
non-loc-lex-item := lex-item & 
 [ SYNSEM.LOCAL.CAT.HEAD.LOC na-or-- ].


speaker-lex-item := basic-icons-lex-item &
  [ SYNSEM.LOCAL.CONT.HOOK [ INDEX #index,
			     SPEAKER-KEY #index ] ].

non-honorific-hearer-lex-item := basic-icons-lex-item &
"""
[FIXME] This was blocking perfectly nice sentence such as: 
你 喜欢 你们 的 外语系 吗 ？
As such I have disabled the honorific/non-honorific system from pronouns.
"""
  [ SYNSEM.LOCAL.CONT.HOOK [ INDEX #index,
			     HEARER-KEY #index ] ].


honorific-hearer-lex-item := one-icons-lex-item & 
  [ SYNSEM.LOCAL.CONT [ HOOK [ INDEX #index,
			       SPEAKER-KEY #skey,
			       HEARER-KEY #index ],
			ICONS <! higher & [ IARG1 #index,
					    IARG2 #skey ] !> ] ].


no-spr-no-spec-lex-item := lex-item & 
 [ SYNSEM.LOCAL.CAT.VAL [ SPR <>, SPEC <> ] ].

redup-lex-item := lex-item & 
 [ SYNSEM [ LOCAL [ CONT [ HOOK [ LTOP #ltop,
				  INDEX #index ],
			   RELS <! #keyrel, #altkeyrel !>,
			   HCONS <! !>, 
			   ICONS <! !> ] ],
	    LKEYS [ KEYREL arg1-relation & event-relation & #keyrel &
			   [ LBL #ltop,
			     ARG0 #index ],
		    ALTKEYREL #altkeyrel & arg1-relation & event-relation &
			   [ LBL #ltop,
			     PRED redup_x_rel,
			     ARG1 #index ] ] ] ].

;;ZZF 20161116, to indicate question words. QUE doesn't work yet, conflicting with basic-head-mod-phrase-simple (non-head QUE 0-dlist) for scopal modifier.
question-item := lex-item &
 [ SYNSEM [ LOCAL.CONT.HOOK.INDEX #ind, 
            NON-LOCAL.QUE <! #ind !> ] ].

;;ZZF 20161128 to indicate non-question words. Matrix has an existing type "zero-arg-nonque", but the name suggests "zero-arg", which may lead to confusion in our usage. Therefore creating a similartype called "nonque-item".
nonque-item := lex-item &
  [ SYNSEM.NON-LOCAL.QUE 0-dlist ].

bound-lex-item := lex-item &
  [ SYNSEM.BOUND + ]. 

;;; Lexical types
normal-lex := lex-item &
"""
All normal lex are not selected by the head. 
Currently being contrasted with KEYS.KEY = selected_rel. 
"""
  [SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY norm_rel].


selected-lex := lex-item &
  [ SYNSEM [ LOCAL [CAT.HEAD.KEYS.KEY #key,
		    CONT [ RELS <! !>, HCONS <! !> ] ],
	     LKEYS.KEYREL.PRED selected_rel & #key,
	     NON-LOCAL.SLASH 0-dlist ] ].


; selected-lex := lex-item & no-rels-hcons-icons-lex-item &
; """
; Trying to use the no-rels-hcons-icons-lex-item type to check if this solves the problem with FFTB.

; """
;   [ SYNSEM [ LOCAL [CAT.HEAD.KEYS.KEY #key,
; 		    CONT [ RELS <! !>, HCONS <! !> ] ],
; 	     LKEYS.KEYREL.PRED selected_rel & #key,
; 	     NON-LOCAL.SLASH 0-dlist ] ].

; [FCB] Do we need to set the ICONs???
; no-hcons-lex-item := lex-item & 
;   [ SYNSEM.LOCAL.CONT.HCONS <! !> ].
; no-rels-hcons-icons-lex-item := no-hcons-lex-item & 
;   [ SYNSEM.LOCAL.CONT [ RELS <! !>, ICONS <! !> ] ].



norm-comps1-lex := lex-item &
"""
This type is to ensure that 1st COMPS of normal verbs have normal (non-empty) semantics.
This is necessary to ensure the contrast with separable verbs like 吃饭. Special
lexical entries for verbs like 吃 expect COMPS with the semantic type selected_rel, 
such as the special 饭_n_selected_rel.
But in order to prevent normal verbs to also take these selected complements as
their own complements, we must ensure all complements of normal verbs are of 
norm_rel.  
"""
[ SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.KEYS.KEY norm_rel] > ].


;;; Nouns

arg1-noun-lex := norm-sem-lex-item & basic-icons-lex-item & 
  [ SYNSEM [ LOCAL.CAT.HEAD noun,
	     LKEYS.KEYREL noun-arg1-relation ]].




noun-lex := basic-noun-lex & basic-one-arg & no-hcons-lex-item & normal-lex &
"""
This inherits from 'normal-lex' which essentially says that these nouns can't be selected for (e.g. separable verbs);

noun-lex basically says that nouns will only have a specifier as ARG, 
and that this specifier's head value is 'det' and it will, itself, be satisfied
concerning any specifier requirements.


[SYNSEM.CLASSIF -] is a new attempt at removing from being a head feature. All nouns will be marked as [CLASSIF -] by default, and this will only be changed to [CLASSIF +] by the mod-head-int rule for classifiers. 
"""
  [ ARG-ST < #spr >,
    SYNSEM [ PAREN -,
             PUNCTUATED -,
             CLASSIF -,
	     LOCAL.CAT.VAL [ COMPS < >,
                             SUBJ < >,
                             SPR < #spr & synsem &
                                   [ LOCAL.CAT [ HEAD det,
                                                 VAL.SPR < > ] ] > ],
             NON-LOCAL.SLASH 0-dlist ] ].

; relational-noun-lex := arg1-noun-lex &
; 		       basic-one-arg &   ; one arg assumes no SPR but one COMP
; 		       no-hcons-lex-item &
; 		       normal-lex &
; """
; it should introce its own quantifier (check another thing that does this)

; Should be further split into a bound one for 里  and nonbound for 里边
; Maybe not bound COMP optional or not.

; (look into quant-nom-lex for the quant relation, probably an exists_q_rel)
; """
;   [ ARG-ST < #comp >,
;     SYNSEM [ PAREN -,
; 	     POSTCOMP +,
;              PUNCTUATED -,
; 	     LOCAL.CAT.VAL [ COMPS < #comp & synsem &
; 				     [ LOCAL [ CAT [ HEAD noun,
; 						     VAL.SPR < > ],
; 					       CONT.HOOK.INDEX ref-ind & #ind ] ] >,
; 			     SUBJ < >,
;                              SPR < > ] ,
;              NON-LOCAL.SLASH 0-dlist,
; 	     LKEYS.KEYREL.ARG1 #ind ] ].




relational-noun-lex := norm-hook-lex-item &
		       basic-one-arg &   ; one arg assumes no SPR but one COMP
		       normal-lex &      ; i.e. not a selected lexicon
"""
General type for nouns that take a complement (i.e. relational nouns).

The current assumption is that these nouns DO NOT take a specifier (however this is heavily influenced by the fact that only locative relational nouns have been tought about). Another related consequence of this is that it introces its own quantifier. (This could be changed if other types of relational nouns are introduced)

This does not constraint the optionality of the COMP (needs to added further down the hierarchy). 

========================
'arg1-noun-lex' inherits from 'norm-sem-lex-item'>>'single-rel-lex-item' that introduces a constraint where there is only a single thing on the RELS list. This is causing problem when we want to add the quantifier directly on the RELS list. The solution for this, is to inherit directly from 'norm-hook-lex-item', which does not put this constraint.

These nouns (and phrases build by them) will get a head feature [LOC +]. This head feature was originally in the grammar but was never used.  This feature, however, should be used to create a mal-rule that can create 'prepositional locative phrases' without 在.  In written Mandarin, 在 is expected in propositions (with some expections in imperatives/suggestions). Not using 在 makes the sentence overly casual, and should be marked for correction.

The restriction [SORT common-s] on the complement prevents both proper nouns and pronouns to be taken as complements -- which is the desired behavior.


The restriction [COMPS < >] for the relational noun's complement is to future proof: in case there are other relational nouns in the future, we would want them to have their COMPS satisfied (or dropped) before being picked up by another relational noun.
"""
  [ ARG-ST < #comp >,
    SYNSEM [ PAREN -,
	     POSTCOMP +,
             PUNCTUATED -,
	     LOCAL [ CAT [ HEAD noun,
			   VAL [ COMPS < #comp & synsem &
					 [ LOCAL [ CAT [ HEAD noun,
							 VAL [ SPR < >,
							       COMPS < > ] ],
						   CONT.HOOK.INDEX ref-ind &
						       #compind ] ] >,
				 SUBJ < >,
				 SPR < > ] ],
		     CONT [ HOOK.INDEX #index,
			    RELS <! #rel &
				  [ LBL #larg ],
				  quant-relation & 
				  [ PRED exist_q_rel,
				    ARG0 #index,
				    RSTR #harg ] !>,
			    HCONS  <! qeq &
				    [ HARG #harg,
				      LARG #larg ] !> ] ] ,
	     NON-LOCAL.SLASH 0-dlist,
	     LKEYS [ KEYREL #rel & [ARG1 #compind] ] ] ].


relational-opt-comp-noun-lex := relational-noun-lex &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ COMPS < synsem & [ OPT + ] > ] ],
		     CONT.HOOK.INDEX.SORT common-s ] ] ].


relational-obl-comp-noun-lex := relational-noun-lex &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ COMPS < synsem & [ OPT - ] > ] ],
		     CONT.HOOK.INDEX.SORT common-s ] ] ].


relational-opt-comp-loc-noun-lex := relational-opt-comp-noun-lex &
"""
This is specifically for locative relational nouns with optional complements.
It introduces the head feature [LOC +], which allows it to go through a pumping rule to become an adjuct.
And it also introduces some contraints on the kind of complements it can take. Currently we want to say that these relational nouns cannot take pronouns or proper nouns (i.e. SORT common-s). And also that it cannot take other nouns that are marked for [LOC +], which would stop sentences like: 
<nex> 她 在 网上 上 学习 汉语 。
The problem with the sentence above is that there will be some (few) nouns that are itself marked for [LOC +], and these would not be able to be picked up by other locative relational nouns.

However this would also block certain nonsensical senteces such as:
<nex> 她 在 上边 上边 学习 汉语 。
[FIXME] This is, in principle, not a bit problem, but not necessarily impossible (???)
"""
  [ SYNSEM.LOCAL.CAT [ HEAD noun & [LOC +],
		       VAL [ COMPS < [ LOCAL [ CAT.HEAD noun & [LOC -],
					       CONT.HOOK.INDEX.SORT common-s ] ] > ] ] ].


relational-obl-comp-loc-noun-lex := relational-obl-comp-noun-lex &
"""
E.g. this is for locative relational nouns with obligatory complements (e.g. 里, 上, 右), that need to take a complement and can't be used by themselves.

It introduces the head feature [LOC +], which allows it to go through a pumping rule to become an adjuct.
And it also introduces some contraints on the kind of complements it can take. Currently we want to say that these relational nouns cannot take pronouns or proper nouns (i.e. SORT common-s). And also that it cannot take other nouns that are marked for [LOC +], which would stop sentences like: 
<nex> 她 在 网上 上 学习 汉语 。
The problem with the sentence above is that there will be some (few) nouns that are itself marked for [LOC +], and these would not be able to be picked up by other locative relational nouns.

However this would also block certain nonsensical senteces such as:
<nex> 她 在 上边 上边 学习 汉语 。
[FIXME] This is, in principle, not a bit problem, but not necessarily impossible (???)
"""
  [ SYNSEM.LOCAL.CAT [ HEAD noun & [LOC +],
		       VAL [ COMPS < [ LOCAL [ CAT.HEAD noun & [LOC -],
					       CONT.HOOK.INDEX.SORT common-s ] ] > ] ] ].




common-noun-lex := noun-lex &
"""
"""
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT common-s ].


nonloc-common-noun-lex := common-noun-lex &
			  non-loc-lex-item
"""
Inheriting from 'non-loc-lex-item' (i.e. [LOC na-or--]) ensures that a NP headed by 'common-noun-lex' can't be pumped into a locative adjunct.  
""".

count-noun-lex := nonloc-common-noun-lex &
  [ SYNSEM [ BARE -,
	     LOCAL.CONT.HOOK.INDEX.SPECI + ] ].

mass-noun-lex := nonloc-common-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SPECI - ].

basic-time-noun-lex :=  basic-one-arg &
			basic-icons-lex-item &
			non-loc-lex-item &
"""
This NONSUBJ feature is used to block certain classes of nouns from becoming subjects.
The 'SORT time-s' should allow these nouns to be selected for some constructions. 
FCB: we can change NONSUBJ to bool and check if the ambiguity shoot up, if it's too bad we might want to say instead that most (99%) of the verbs don't accept a time-s subject. but ADJ-predicates do, and 是 also does. 

Testing removing NONSUBJ as a restriction. This was blocking sentences like:
<ex> 一月 是 我 最 喜欢 的 月份 。
Or 
<ex> 昨天 很 热 。
from parsing or from parsing with adequate semantics.
This does not rule out the possibility of blocking certain types of subjects
in major classes of verbs (due to semantic oddity). this can use SORT on SUBJ.

Inheriting from 'non-loc-lex-item' (i.e. [LOC na-or--]) ensures that a NP headed by 'common-noun-lex' can't be pumped into a locative adjunct.  
"""
  [ SYNSEM [ PAREN -,
             PUNCTUATED -,
	     LOCAL [ CAT [ HEAD noun,
			   VAL.SUBJ < > ],
; 			   VAL.SUBJ < >,
; 			   NONSUBJ + ],
		     CONT [ HOOK.INDEX.SORT time-s,
			    RELS.LIST.FIRST #keyrel ] ],
	     NON-LOCAL.SLASH 0-dlist,
	     LKEYS.KEYREL #keyrel ] ].

norm-time-noun-lex := basic-time-noun-lex & norm-sem-lex-item & no-hcons-lex-item
"""
This level exists to differentiate between time-noun-lex and bound-time-noun-lex.
So there must be a reason for norm-sem-lex-item & no-hcons-lex-item  [FIXME] find 
out what that is.
""".

time-noun-lex := norm-time-noun-lex &
"""
For example, for entries like: 'day'
"""
  [ ARG-ST < #spr >,
    SYNSEM [ LOCAL.CAT.VAL [ SPR < #spr &
				   synsem &
				   [ LOCAL.CAT [ HEAD det,
						 VAL.SPR < > ] ] >,
			     COMPS < > ] ] ].


bound-time-noun-lex := basic-time-noun-lex &
"""
Maybe only for: 'o'clock' and 'minute'
"""
  [ SYNSEM.LOCAL [ CAT.VAL [ SPR < anti-synsem & [ OPT - ] >,
			     COMPS < > ],
		   CONT [ HOOK [ LTOP #ltop,
				 INDEX #index ],
			  RELS <! [ LBL #ltop,
				    ARG0 #index ] !>,
			  HCONS <! !> ] ] ].


proper-name-lex := quant-pronproper-lex & zero-arg-nonque &
"""
This type introduces named_rel and proper_q_rel in named entities.
<ex> 张三 哭 了

One could select this by saying it's a named relation;
"""
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT pronproper-s,
    SYNSEM.LKEYS.KEYREL named-relation,
    SYNSEM.LKEYS.ALTKEYREL.PRED proper_q_rel].



loc-name-lex := proper-name-lex & loc-lex-item & non-human-lex-item
"""
SSH 2014-09-11: Locative Proper Names (e.g. 北京).
我 要 去 北京: I would like to go to Beijing.
*我 要 去 李四 / 我 要 去 李四 的 家
""".

nonloc-name-lex := proper-name-lex & non-loc-lex-item.

human-name-lex := nonloc-name-lex & human-lex-item. 

surname-lex := human-name-lex
"""
For Surnames. Usually one character long.
""".



quant-nom-lex := norm-hook-lex-item & zero-arg-nonslash & zero-arg-nonrel &
"""
SSH 2014-11-13: pronouns introduce a quant-relation. 
Pronouns don't have NON-LOCAL.SLASH and REL.
Pronouns are not of SORT 'pronproper-s' (pronoun or proper name).
"""
  [ SYNSEM [ PAREN -,
             PUNCTUATED -,
	     LOCAL [ CAT [ HEAD noun,
			   VAL [ COMPS < >,
				 SUBJ < >,
				 SPR < > ] ],
		     CONT [ HOOK.INDEX #index,
			    RELS <! #rel &
				  [ LBL #larg ],
				  #quant & 
				  [ ARG0 #index,
				    RSTR #harg ] !>,
			    HCONS <! qeq & 
				   [ HARG #harg, 
				     LARG #larg ] !> ] ],
	     LKEYS.KEYREL noun-relation & #rel,
	     LKEYS.ALTKEYREL quant-relation & #quant ] ].


quant-pronproper-lex := quant-nom-lex &
"""
things ther are eitehr pronouns or proper nouns inhertit from this 
and get the right SORT
"""
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT pronproper-s ].


;; SSH 2014-11-13: pronouns introduce a quant-relation. 
basic-pronoun-lex := quant-pronproper-lex &
"""
Pronouns don't have NON-LOCAL.SLASH and REL
"""
  [ SYNSEM.LKEYS.KEYREL.PRED pron_rel ].


personal-pronoun-lex := basic-pronoun-lex & zero-arg-nonque & non-loc-lex-item &
  [ SYNSEM.LKEYS.ALTKEYREL.PRED pronoun_q_rel ].


super-wh-pronoun := quant-pronproper-lex &
"""
This type is the super-type of many different interrogative pronouns.
One important distinction is that some of these should not be able to be pumped into place adjucts (but some should, e.g. 哪儿, 哪里).

It is very likely that, in the future, 什么_n_q would be removed from this cat (to become an adjectival question word), but the problem will remain with 谁, 哪, etc. 
"""
  [SYNSEM [ LOCAL.CONT [ HOOK [ INDEX #index & [ PNG.PERNUM 3rd ],
                                ICONS-KEY #icons,
				CLAUSE-KEY #clause ],
                         ICONS <! semantic-focus & #icons &
                                [ IARG1 #clause,
                                  IARG2 #index ] !> ],
            NON-LOCAL.QUE <! #index !>,
            LKEYS.ALTKEYREL.PRED which_q_rel ] ].


wh-pronoun := quant-pronproper-lex &
"""
This is the subtype for generic, it is assumed that it CANNOT be pumped to a place adjunct.

[LOC -] blocking these from being pumped into place locatives, without the use of a preposition or locative noun. 
"""
  [ SYNSEM.LOCAL.CAT.HEAD.LOC - ].

loc-wh-pronoun := super-wh-pronoun &
"""
This type is for locative interrogative pronouns, such as 哪里 and 哪儿.

[LOC +] allowing these to be pumped into place locatives, without the use of a preposition or locative noun.  
"""
  [ SYNSEM.LOCAL.CAT.HEAD.LOC + ].



loc-pronoun-lex := basic-pronoun-lex & zero-arg-nonque & loc-lex-item.
;  [ SYNSEM.LKEYS.ALTKEYREL.PRED pronoun_q_rel ].

quant-noun-lex := quant-nom-lex & basic-icons-lex-item &
"""
SSH 2014-11-13: 大家 (everyone), etc.

 generic_n_rel can be further specified as one of these in the lexical entry:
zhong.tdl:146:thing_n_rel := generic_n_rel.
zhong.tdl:147:place_n_rel := generic_n_rel.
zhong.tdl:148:person_n_rel := generic_n_rel.
zhong.tdl:149:time_n_rel := generic_n_rel 
"""
  [ SYNSEM [ LOCAL.CONT.RELS <! relation,
			      #altkeyrel !>,
	     LKEYS [ KEYREL.PRED generic_n_rel,
		     ALTKEYREL #altkeyrel ] ] ].

quant-common-noun-lex := quant-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT common-s ].


nominalizer-lex := lex-item &
  [ ARG-ST < #spr >,
    SYNSEM [ PAREN -,
             PUNCTUATED -,
	     LOCAL [ CAT [ HEAD noun,
                           VAL [ COMPS < >,
                                 SUBJ < >,
                                 SPR < #spr &
                                       [ LOCAL [ CAT [ HEAD +vjp & [ MOD < > ],
                                                       VAL [ SUBJ olist,
                                                             SPR olist,
                                                             COMPS < > ] ],
                                                 CONT.HOOK [ LTOP #spltop,
                                                             INDEX.SF prop ] ] ],
                                       anti-synsem > ] ],
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #index & [ SORT nontime-s ] ],
                            RELS <! relation & #keyrel & 
                                  [ LBL #ltop,
                                    ARG0 #index ] !>,
                            HCONS <! !>,
                            ICONS <! !> ] ],
             NON-LOCAL [ SLASH 0-dlist,
                         REL 0-dlist,
                         QUE 0-dlist ],
             LKEYS.KEYREL #keyrel &
                   [ ARG0.PNG.PERNUM 3rd,
                     ARG1 #spltop ] ] ].


; Partitive determiner
partitive-lex := basic-one-arg & no-icons-lex-item &
  [ ARG-ST < #comp >,
    SYNSEM [ PAREN -,
	     PUNCTUATED -,
	     LOCAL 
		   [ CAT [ HEAD noun,
			   VAL [ COMPS < #comp &
					 [ LOCAL [ CAT [ HEAD adj &
							      [ MOD < [ LOCAL.CONT.HOOK.INDEX 
											      #index ] > ],
							 VAL [ SUBJ < [ ] >,
							       COMPS < > ] ],
						   CONT.HOOK.LTOP #larg ],
					   NON-LOCAL.SLASH 0-dlist ] >,
				 SUBJ < >,
				 SPR < > ] ],
		     CONT [ HOOK.INDEX #index & [ SORT nontime-s ],
			    RELS <! quant-relation & #keyrel &
				  [ ARG0 #index,
				    RSTR #harg ],
				  #altkeyrel & relation &
				  [ LBL #larg,
				    PRED generic_n_rel,
				    ARG0 #index ] !>,
			    HCONS <! qeq & 
				   [ HARG #harg,
				     LARG #larg ] !> ] ],
	     NON-LOCAL.SLASH 0-dlist,
	     LKEYS.KEYREL #keyrel,
	     LKEYS.ALTKEYREL #altkeyrel] ].

;;; Verbs

; head :+ 
+vj :+ 
"""
Even though the features that are defined here seem best only used by verbs (i.e. head :+ ), doing this eliminates many parses (although many were problem incorrect to start with). 

One weird example seems to be the use of 的.
 厚厚 的 地毯
"""
  [ AUX bool,
    COP bool,
    FORM form ].

;; SSH 2014-12-09 adj -> +vj
;; SSH 2014-12-19 +vj -> +vjr
+vjr :+
  [ PRD bool ].

verb-lex := lex-item &
"""
VAL.SPR is not set to empty < > to allow some verbs to take degree specifiers
"""
  [ SYNSEM [ PAREN -,
             PUNCTUATED -,
	     LOCAL.CAT.HEAD verb & [ PRED-KEY #pred ],
	     LKEYS.KEYREL.PRED #pred ] ].

main-verb-lex := verb-lex & basic-verb-lex & tentative-lex-dtr & 
  [ SYNSEM.LOCAL [ CAT [ HEAD.AUX -,
                         VAL.SUBJ < #subj > ],
                   CONT.HOOK.XARG #xarg ],
    ARG-ST.FIRST #subj &
                 [ LOCAL [ CAT.VAL [ SPR < >,
                                     COMPS < > ],
                           CONT.HOOK.INDEX #xarg ] ] ].

verb-spr-item := lex-item &
"""
These are verbs that can take degree specifiers (mental activities and states).
<ex>他 很 喜欢 狗 。
FIXME: Why isn't this inheriting from verb-lex instead of lex-item?
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CAT [ HEAD adv,
                                             VAL.SPEC < [ LOCAL.CAT.HEAD verb ] > ] ] > ].

verb-no-spr-item := lex-item &
"""
These are verbs that can't take degree specifiers (i.e., most of the verbs).
<nex>他 很 买 狗 。
FIXME: Why isn't this inheriting from verb-lex instead of lex-item?
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPR <  > ].

aux-lex := verb-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.AUX + ].

;; SSH 2014-09-03: ICONS in 谁 的 狗 叫 了
;; Because Chinese employs classifiers, and sometimes the classifiers
;; convey focus, CLAUSE-KEY should be used, instead of merely
;; ICONS-KEY.CLAUSE.
intransitive-lex-item :+ 
[ ARG-ST < [ LOCAL.CONT.HOOK.CLAUSE-KEY #clause ] >,
  SYNSEM.LOCAL.CONT.HOOK.CLAUSE-KEY #clause ].

intransitive-verb-lex := main-verb-lex & intransitive-lex-item & aspect-rule-dtr &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    ARG-ST.FIRST.LOCAL.CAT.HEAD noun ].


transitive-super-lex-item := basic-two-arg-no-hcons & basic-icons-lex-item &
"""
This is the parent of both normal transitive lex items and separable transive lex item.

This is to allow sep-verbs not to have an ARG 2 while taking a complement.
It says: they as all in the same clause. (clause-key is the same).
"""
   [ ARG-ST < [ LOCAL.CONT.HOOK.CLAUSE-KEY #clause ],
	      [ LOCAL.CONT.HOOK.CLAUSE-KEY #clause ] >,
     SYNSEM [ LOCAL.CONT.HOOK.CLAUSE-KEY #clause ] ].

transitive-lex-item := transitive-super-lex-item &
"""
This was redefined from the original Matrix type to allow sentential subjects.
In normal transitive lexical items (verbs) the ARG2 is coindexed with the second 
thing of the Argument Structure.

This split (from 'transitive-sep-lex-item'), also allows us to make another distinction: normal transitive-lex-items will require a COMP that is [BOUND -], and transitive-sep-lex-items will require a COMP that is [BOUND +]. This restriction will no longer be included as part of head-comp rule. 
"""
  [ ARG-ST < synsem, [ BOUND -,
		       LOCAL.CONT.HOOK [ INDEX ref-ind & #ind2 ] ] >,
    SYNSEM [ LKEYS.KEYREL.ARG2 #ind2 ] ].


transitive-sep-lex-item := transitive-super-lex-item &
"""
In the case of separable transitive lexical items (i.e. sep-verbs), there won't be a ARG2 in the semantics, even though it will be linked by a head-comp rule.

This split (from 'transitive-lex-item'), also allows us to make another distinction: normal transitive-lex-items will require a COMP that is [BOUND -], and transitive-sep-lex-items will require a COMP that is [BOUND +]. This restriction will no longer be included as part of head-comp rule. 
"""
  [ ARG-ST < synsem, [ BOUND +,
		       LOCAL.CONT.HOOK [ INDEX event ] ] > ].




transitive-verb-lex := main-verb-lex & transitive-lex-item & aspect-rule-dtr &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < #comp >,
	     LKEYS.KEYREL.ARG1 #index ],
    ARG-ST < [ LOCAL [ CAT.HEAD noun,
		       CONT.HOOK.INDEX #index ] ],
	     #comp &
	     [ LOCAL.CAT [ VAL [ SPR < >,
				 COMPS < > ],
			   HEAD noun ] ] > ].

cp-subj-verb-lex := main-verb-lex & transitive-lex-item & aspect-rule-dtr & verb-no-spr-item &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < #comp >,
         LKEYS.KEYREL.ARG1 #ltop ],
    ARG-ST < [ LOCAL [ CAT [ HEAD +vjp,
                 VAL [ SUBJ < >,
                   COMPS < > ] ],
               CONT.HOOK.LTOP #ltop ] ],
             #comp &
             [ LOCAL.CAT [ VAL [ SPR < >,
                                 COMPS < > ],
                           HEAD noun ] ] > ].

;; SSH 2014-09-08: added [MC +] to block overgeneration
;; 张三 知道 下 过 雨
;; ZZF FB LMC 2016-2-24 expand to adj predicate, and SPR of comp to be olist instead of < >
;; FIXME: we need to put in HCON later
s-comp-verb-lex := main-verb-lex  & basic-two-arg-no-hcons & basic-icons-lex-item & aspect-rule-dtr &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < #comp >],
	     LKEYS.KEYREL[ARG1 #ind,
			  ARG2 #ltop]],
    ARG-ST < [ LOCAL [ CAT.HEAD noun,
		       CONT.HOOK.INDEX #ind]],
	     #comp &
	     [ LOCAL [ CAT [ MC +,
			     VAL [ SUBJ <>,
				   SPR olist,
				   COMPS < > ],
			     HEAD +vj ],
		       CONT.HOOK.LTOP #ltop],
	       OPT -]> ].

v_s-comp-lex := s-comp-verb-lex & verb-no-spr-item.

v_s-comp-spr-lex := s-comp-verb-lex & verb-spr-item.

;vp-comp-verb-lex := main-verb-lex & basic-two-arg-no-hcons & basic-icons-lex-item & aspect-rule-dtr &


vp-comp-verb-lex := main-verb-lex & basic-two-arg & basic-icons-lex-item & aspect-rule-dtr &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < #comp >,
	     LKEYS.KEYREL [ ARG1 #ind ] ],
    ARG-ST < [ LOCAL[ CAT.HEAD noun,
		      CONT.HOOK.INDEX #ind ] ],
	     #comp &
             [ LOCAL[ CAT [ VAL [ SUBJ < [] >,
				  SPR < >,
				  COMPS < > ],
			    HEAD verb ] ],
	       OPT - ] > ].

vp-comp-verb-seq-lex := vp-comp-verb-lex &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.MC na-or--,
					     CONT.HOOK.XARG #xarg ] ] >,
		   CONT.HOOK.XARG #xarg ] ].


np-xp-comp-verb-lex := main-verb-lex & basic-three-arg & basic-icons-lex-item & verb-no-spr-item &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < #comp1, #comp2 >,
	     LKEYS.KEYREL [ ARG1 #ind,
			    ARG2 #ind2 ] ],
    ARG-ST < [ LOCAL [ CAT [ HEAD noun,
			     VAL.SPR < > ],
		       CONT.HOOK.INDEX #ind ] ],
	     #comp1 &
	     [ LOCAL [ CAT [ HEAD noun,
			    VAL.SPR < > ],
		       CONT.HOOK.INDEX #ind2 ] ],
	     #comp2 &
	     [ LOCAL [ CAT [ VAL [ SUBJ < unexpressed >,
				   COMPS < > ],
			     HEAD +vj ] ],
	       OPT - ]> ].

np-vp-comp-verb-lex := np-xp-comp-verb-lex &
"""
The [OPT -] for the first complement predicts that these verbs can never drop 
this first complement (although the second one is acceptable). 
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ], [ LOCAL.CAT.HEAD verb ] > ].

; `wipe the table clean'
np-ap-comp-ba-verb-lex := np-xp-comp-verb-lex &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < gap, [ LOCAL.CAT.HEAD adj ] > ].

np-ap-comp-verb-lex := np-xp-comp-verb-lex &
"""
Verb with two complements. The first is headed by a noun, and the second is headed by an adjective.
e.g. 'I consider him old'
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ ], [ LOCAL.CAT.HEAD adj ] > ].

np-vp-comp-verb-oeq-lex := np-vp-comp-verb-lex &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #xarg ],
				 [ LOCAL [ CAT.MC na-or--,
					   CONT.HOOK.XARG #xarg ] ] > ].


;; SSH 2014-12-08: na-or-- is added 
;; 张三 答应 李四 去 北京 。
;; ZZF 2016-12-5: renamed it to be "seq" instead of "anomeq"
np-vp-comp-verb-seq-lex := np-vp-comp-verb-lex &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #xarg ] >,
			   COMPS < [ ],
				   [ LOCAL [ CAT.MC na-or--,
					     CONT.HOOK.XARG #xarg ] ] > ] ].

;; ZZF 2017-08-01 我 问 他 你 在 忙 吗 ？
v_np-s_lex := main-verb-lex & basic-three-arg & basic-icons-lex-item & verb-no-spr-item &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < #comp1, #comp2 >,
	     LKEYS.KEYREL [ ARG1 #ind,
			    ARG2 #ind2 ] ],
    ARG-ST < [ LOCAL [ CAT [ HEAD noun,
			     VAL.SPR < > ],
		       CONT.HOOK.INDEX #ind ] ],
	     #comp1 &
	     [ LOCAL [ CAT [ HEAD noun,
			    VAL.SPR < > ],
		       CONT.HOOK.INDEX #ind2 ] ],
	     #comp2 &
	     [ LOCAL [ CAT [ VAL [ SUBJ < >,
				   COMPS < > ],
			     HEAD +vj ] ],
	       OPT - ]> ].

;; SSH 2014-09-08: The following sentence should be analyzed as being
;; [ASPECT perfective].
;; 张三 把 香烟 递 给 了 李四
np-vp-comp-verb-light-lex := np-vp-comp-verb-lex & basic-three-arg-no-hcons & 
"""
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ ],
				   [ LOCAL.CONT.HOOK [ XARG #event,
						       INDEX.E.ASPECT #aspect ] ] >,
		   CONT.HOOK.INDEX #event & [ E.ASPECT #aspect ] ] ].


pp-s-comp-verb-lex := main-verb-lex & basic-three-arg-no-hcons & basic-icons-lex-item &
		      aspect-rule-dtr & verb-no-spr-item &
"""
These verbs take two COMPs: a PP (optional?)  + and a non-optional S.

There is currently only 1 verb under this type: 保证
I assume this was to be able to deal withsentences like:
<ex> 我 向 你 保证 学习 。
(I promise you to study)
But this is still not parsing as predicted.  [向 你] cannot be a COMP.
[FIXME][FCB] Maybe this has to do with being a pre-head COMP? 
"""
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < #comp1, #comp2 >,
	     LKEYS.KEYREL [ ARG1 #ind,
			    ARG2 #ind2,
			    ARG3 #ltop ] ],
    ARG-ST < [ LOCAL [ CAT.HEAD noun,
		       CONT.HOOK.INDEX #ind ] ],
	     #comp1 &
	     [ LOCAL [ CAT.HEAD adp,
		       CONT.HOOK.INDEX #ind2 ] ],
	     #comp2 &
	     [ LOCAL [ CAT [ VAL [SUBJ < >,
				  SPR < >,
				  COMPS < > ],
			     HEAD verb ],
		       CONT.HOOK.LTOP #ltop],
	       OPT -]> ].

;;2016-2-16 ZZF OPT + to allow objects to be optional ::testing
super-ditrans-verb-lex := main-verb-lex & aspect-rule-dtr & verb-no-spr-item &
"""
Currently all ditransitive verbs are [BOUND -], blocking the complements of separable verbs from unifying. 

"""
 [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comp1, #comp2>,
   ARG-ST  < [ LOCAL.CAT.HEAD noun ],
             #comp1 &
             [ BOUND -,
	       LOCAL.CAT [ VAL [ SPR < >,
                                 COMPS < > ],
                           HEAD noun ], 
               OPT +] ,
             #comp2 &
             [ BOUND -,
	       LOCAL.CAT [ VAL [ SPR < >,
                                 COMPS < > ] ],
               OPT +] >].

ditrans-verb-lex := ditransitive-lex-item & super-ditrans-verb-lex
"""
"""
.

ditransitive-lex-item-2 := basic-three-arg & basic-icons-lex-item &
"""
This seems to be an alternative for ditransitive verbs where the second complement is QEQ'ed with the verb's ltop. It was exclusively used for 'ditrans-pp-verb-lex', which specifies the 

[FIXME] I believe this is generating some weird parses.

"""
   [ ARG-ST < [ LOCAL.CONT.HOOK [ INDEX ref-ind & #ind1,
				  ICONS-KEY.IARG1 #clause ] ],
	      [ LOCAL.CONT.HOOK [ INDEX ref-ind & #ind2,
				  ICONS-KEY.IARG1 #clause ] ],
	      [ LOCAL.CONT.HOOK [ INDEX event,
                                  LTOP #ltop, 
                                  XARG #ind2,
				  ICONS-KEY.IARG1 #clause ] ] >,
     SYNSEM [ LKEYS.KEYREL [ ARG1 #ind1,
			     ARG2 #ind2,
			     ARG3 #ind3 ],
	      LOCAL.CONT [ HOOK.CLAUSE-KEY #clause,
                           HCONS <! qeq & [ HARG #ind3, 
                                            LARG #ltop ] !> ] ] ].

ditrans-pp-verb-lex := ditransitive-lex-item-2 & super-ditrans-verb-lex &
"""
"""
 [ ARG-ST  < [], [], [ LOCAL.CAT.HEAD adp & [ PFORM gei-or-xiang ] ] > ].

ditrans-preverbal-pp-verb-lex := ditrans-pp-verb-lex &
"""
"""
 [ ARG-ST  < [], [], [ LOCAL.CAT [ HEAD [ PFORM xiang ] ] ] > ].


trans-loc-verb-lex := basic-three-arg-no-hcons & main-verb-lex & basic-icons-lex-item &
		      aspect-rule-dtr & verb-no-spr-item &
"""
This type is for ditransitive verbs where the second complement is a PP (unconstrained).
The original name was 'trans-loc-verb-lex' but this seems a bit 

"""
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < #comp1,#comp2>,
	     LKEYS.KEYREL [ ARG1 #arg1, 
			    ARG2 #arg2,
			    ARG3 #arg3 ] ],
    ARG-ST  < [ LOCAL [ CAT.HEAD noun,
			CONT.HOOK.INDEX #arg1 ] ],
	      #comp1 &
	      [ LOCAL [ CAT [ VAL [ SPR < >,
				    COMPS < > ],
			      HEAD noun ],
			CONT.HOOK.INDEX #arg2 ],
		OPT - ],
	      #comp2 &
	      [ LOCAL [ CAT [ VAL [ SPR < >,
				    COMPS < > ],
			      HEAD prep],
			CONT.HOOK.INDEX #arg3 ],
		OPT -] > ].

v_intrans-verb-lex := intransitive-verb-lex & verb-no-spr-item
"""
""".

v_intrans-verb-spr-lex := intransitive-verb-lex & verb-spr-item
"""
""".

v_trans-verb-lex := transitive-verb-lex & verb-no-spr-item
"""
""".

v_trans-verb-spr-lex := transitive-verb-lex & verb-spr-item
"""
""".



;; WWJ 2015-02-08: Changed HEAD of #subj to be noun and postp (instead of just postp)
;; to account for cases like 学校 有 狗 or 盒子 有 蛋糕, where the PP might be omitted
;; EXISTV has been added as a property to block 不 有

v_exist-lex := basic-three-arg &
	       verb-lex &
	       basic-verb-lex &
	       basic-icons-lex-item &
	       verb-no-spr-item &
"""
Currently this is being used for sentences like: 学校 里 有 狗 叫
[FIXME] It's not clear whether this is absolutely necessary, or why is it not picking up examples such as 有 一 个 人 来 我 的 家 。

The subject is now requesting for [ HEAD noun & [LOC +] ] to account for the new way relational locative nouns are being handled.

[FIXME] Should double check if 在 phrases are not equally acceptable. However, it is also plausible to assume that in the presence of a 在 phrase, it should be handled as an adjunct. This option (which would require discharging the subject), however, is being blocked by [EXISTV +] -- which is being blocked by 'opt-subj-declarative-phrase'.
"""
 [ SYNSEM [ POSTCOMP -,
	    LOCAL [ CAT.VAL [ SUBJ < #subj >,
			      COMPS < #comp1, #comp2 > ],
		    CAT.HEAD [ EXISTV +,
			       AUX -,
			       COP - ],
                    CONT [ HOOK [ LTOP #lbl,
				  INDEX #event ],
			   RELS <! #keyrel !>,
                           HCONS <! qeq & [ HARG #arg2,
					    LARG #vltop ] !> ] ],
	    LKEYS.KEYREL #keyrel &
                  [ LBL #lbl,
		    ARG0 #event,
		    ARG1 #arg1,
		    ARG2 #arg2,
		    ARG3 #arg3 ] ],
   ARG-ST 
	  < #subj &
	    [ OPT +, ; allowing optional but not slashed subjects
	      LOCAL [ CAT [ VAL [ SPR < >,
				  COMPS < > ],
			    HEAD noun & [LOC +] ],
		      CONT.HOOK.INDEX #arg3 ],
	      NON-LOCAL.SLASH 0-dlist ],
	    #comp1 &
	    [ LOCAL [ CAT [ VAL [ SPR < >,
				  COMPS < > ],
			    HEAD noun ],
		      CONT.HOOK.INDEX #arg1 ] ],
	    #comp2 &
	    [ LOCAL [ CAT [ VAL [ SUBJ < [ ] >,
				  SPR < >,
				  COMPS < > ],
			    HEAD verb ],
		      CONT.HOOK [ LTOP #vltop,
				  XARG #arg1 ] ] ] > ].

v_light-verb-lexeme := main-verb-lex & basic-two-arg-no-hcons &
		       basic-icons-lex-item & verb-no-spr-item &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < #comp >,
                     CONT.HOOK.XARG #arg1 ],
             LKEYS.KEYREL [ ARG1 #arg1,
			    ARG2 #ind2 ] ],
    ARG-ST < unexpressed & [ LOCAL.CAT.HEAD noun ],
             #comp &
             [ LOCAL [ CAT [ VAL [ SPR < >,
                                   COMPS < > ],
                             HEAD noun ],
               CONT.HOOK.INDEX ref-ind & #ind2 ] ] > ].

v_light-verb-lex := v_light-verb-lexeme &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY #pred,
             LKEYS.KEYREL.PRED #pred ] ].

v_sequi-lex := vp-comp-verb-seq-lex & trans-first-arg-control-lex-item & verb-no-spr-item.

v_sequi-spr-lex := vp-comp-verb-seq-lex & trans-first-arg-control-lex-item & verb-spr-item.

v_np-vp_oequi-lex := np-vp-comp-verb-oeq-lex & ditrans-second-arg-control-lex-item
"""
 
""".


v_np-vp_sequi-lex := np-vp-comp-verb-seq-lex & ditrans-first-arg-control-lex-item.

;v_a-equi-lex := np-vp-comp-verb-anomeq-lex & ditrans-first-arg-control-lex-item.

v_np-vp_light-lex := np-vp-comp-verb-light-lex.

v_pp-lex := basic-two-arg & main-verb-lex & basic-icons-lex-item & verb-no-spr-item &
"""
Basic transitive verb type with a single prepositional complement.
The value [HEAD adp] of the complement technically allows the complment to be 
either a preposition or a postposition.

Selection of which preposition is currently done through adding something
similar to [LOCAL.CAT.HEAD.PFORM gei] on the complment of each lexical entry.

In due time, and given the scarcity of such verbs and prepositions, it could 
probably make sense to create a verb type for each prepositional complement 
(e.g. v_zai_pp).

[FIXME][FCB]?
Semantically, these verbs are linking the prepositional phrase to the subject.
This strikes me as odd. The ERG treats 'He lives in Paris' as a prepositional 
verb but does not link the pronoun with 'in Paris'.

But currently, ZHONG parses: 
<ex> 她 坐 在 沙发 。
But links things incorrectly.
"""
  [ ARG-ST < [ LOCAL.CONT.HOOK [ INDEX ref-ind & #ind1,
				 ICONS-KEY.IARG1 #clause ] ],
	     #comp & [ LOCAL.CONT.HOOK [ INDEX event,
					 LTOP #ltop,
					 XARG #ind1,
					 ICONS-KEY.IARG1 #clause ] ] >,
    SYNSEM [ LKEYS.KEYREL [ ARG1 #ind1,
			    ARG2 #ind2 ],
	     LOCAL [ CAT.VAL.COMPS < #comp & [ LOCAL.CAT.HEAD adp ] >,
		     CONT [ HOOK.CLAUSE-KEY #clause,
			    HCONS <! qeq & [ HARG #ind2,
					     LARG #ltop ] !> ] ] ] ].

;;ZZF & FB 2016-3-23: defining a special "verb-particle" for SUO
v_suo_lex := basic-one-arg-no-hcons & verb-lex & basic-icons-lex-item &
[ SYNSEM [ LOCAL [ CONT [ HOOK #hook,
                          RELS <!!> ],
                   CAT [ MC +,
                         VAL [  SUBJ < [ LOCAL [ CAT [ HEAD noun,
						       VAL [ SPR <>, 
							    COMPS <> ] ],
                                                 CONT.HOOK.INDEX #isubj ],
					 OPT +] >,
                               COMPS < [ LOCAL [ CAT [ HEAD verb & [ AUX - ],
						       VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #isubj ] >,
							     COMPS < [ LOCAL #slash & 
                                                                          [ CAT [ HEAD noun,
								            VAL [ SPR <>,
								                  COMPS <>]]]]> ]],
                                                 CONT.HOOK #hook ] ] > ] ] ],
            NON-LOCAL.SLASH <! #slash !>
             ] ].


;; SSH 2014-09-02: To block overgeneration (e.g. *李四 被 了 张三 追赶),
;; I added [POSTHEAD +].
v_npvpslash_type_lex := basic-two-arg-no-hcons & verb-lex & basic-icons-lex-item &
[ SYNSEM [ LOCAL [ CAT [ POSTHEAD +,
			 VAL [ COMPS <[ LOCAL [ CAT [ HEAD noun,
						      VAL [ SPR <>, 
							    COMPS <>]]],
					NON-LOCAL.SLASH <! !>],
				      [ LOCAL [ CAT [ HEAD verb,
						      VAL [ SUBJ < [ NON-LOCAL.SLASH <! !> ] >,
							    COMPS <>]],
						CONT.HOOK #hook],
					OPT -,
					NON-LOCAL.SLASH <! [ CAT[ HEAD noun,
								  VAL [ SPR <>,
								      COMPS <>]]] !>]>,
			       SPR <>,
			       SUBJ < [ LOCAL [ CAT [ HEAD noun,
						      VAL [ SPR <>, 
							    COMPS <>]]],
					NON-LOCAL.SLASH #slash,
					OPT -] > ],
			 HEAD [ AUX +] ],
		   CONT [ HOOK #hook,
			  RELS <!!>]],
	   NON-LOCAL.SLASH #slash ] ].
  
  
v_bei_type_lex := v_npvpslash_type_lex &
[ SYNSEM.LOCAL.CAT.VAL [ COMPS < [ LOCAL [ CONT.HOOK.INDEX #ind1 ],
				   OPT +],
				 [ LOCAL [ CAT [ VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #ind1 ] > ] ] ],
				   OPT -,
				   NON-LOCAL.SLASH <! [CONT.HOOK.INDEX #ind2] !>]>,
			 SUBJ < [ LOCAL [ CONT.HOOK.INDEX #ind2 ] ] > ] ].

v_ba_type_lex := v_npvpslash_type_lex &
[ SYNSEM.LOCAL.CAT.VAL [ COMPS < [ LOCAL[ CONT.HOOK.INDEX #ind1,
					  COORD #coord],
				   OPT -],
				 [ LOCAL [ CAT [ VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #ind2] > ] ] ],
				   OPT -,
				   NON-LOCAL.SLASH <! [CONT.HOOK.INDEX #ind1,
						       COORD #coord ] !> ] >,
			 SUBJ < [ LOCAL[ CONT.HOOK.INDEX #ind2 ] ] > ] ].
  
                
v_weather_type_lex := verb-lex &
		      basic-icons-lex-item &
		      aspect-rule-dtr &
		      verb-no-spr-item &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ <>,
				 SPR <>,
				 COMPS < [ LOCAL [ CAT [ HEAD noun,
							 VAL [SPR <>, 
							      COMPS <> ] ],
						   CONT.HOOK.INDEX #ind ] ] > ] ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX #event],
			    RELS <! #keyrel & 
				  [ ARG0 #event,
				    LBL #ltop,
				    ARG1 #ind ] !> ] ],
	     LKEYS.KEYREL #keyrel,
	     NON-LOCAL.SLASH 0-dlist ] ].


;;;Adverbs

;;redefining the types in matrix.tdl. Taken out raise-index-mod-lex-item from basic-adverb-lex and put it in basic-scopal-adverb-lex. 
basic-adv-lex :=  single-rel-lex-item & basic-icons-lex-item &
  [ SYNSEM [ PUNCTUATED -,
             LOCAL.CAT.HEAD adv,
	     LKEYS.KEYREL event-relation ]].

;;zzf and fb 2016-11-7  
;;raise-index-mod-lex-item its HOOK.INDEX is the same as that of the thing it modifies
;;removing SPR as scopal adverbs don't seem to take degree specifiers.
basic-scopal-adv-lex := basic-adv-lex & scopal-mod-lex & raise-index-mod-lex-item &
  [ SYNSEM [ PAREN -,
	     LOCAL.CAT.VAL [ SUBJ < >,
                             SPR < > ] ] ].
;;                             SPR < [ LOCAL.CAT [ HEAD adv,
;;                                                 VAL.SPEC < [ LOCAL.CAT.HEAD adv ] > ] ] ;;> ] ] ].


;;add in norm-hook-lex-item, so that it's keyrel.arg0 is its hook.index
basic-int-adv-lex := basic-adv-lex & intersective-mod-lex & norm-hook-lex-item &
"""Its ARG1 refers to what it modifies, through XARG. CONT.HOOK.XARG #ind 
"""
  [ SYNSEM [ PAREN -,
	     LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #ind ] >,
			   VAL.SUBJ < > ], 
		     CONT.HOOK.XARG #ind ],
	     NON-LOCAL.SLASH 0-dlist,
             LKEYS.KEYREL.ARG1 #ind ] ].

;;Non-moveable manner adverbs

;; WWJ 2015-04-07: Added such that modified item has to be [ MODIFIABLE + ]

int-adv-vp-pre := basic-int-adv-lex &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MOD < [ 	LOCAL.CAT [ HEAD verb & [ MODIFIABLE + ],
						  VAL [ SUBJ < [] >,
							COMPS < > ] ] ] >,
			 VAL [ COMPS < >,
			       SPR < > ],
			 POSTHEAD - ] ] ].

;; SSH 2014-09-02: To block generation (e.g., 狗 在 在 在 ... 叫), I
;; added [MODIFIED notmod].
;; WWJ 2015-03-26: Added [ MODIFIABLE + ] so it won't modify A-NOT-A phrases
int-adv-vp-pre-no-rel := intersective-mod-lex & basic-icons-lex-item &
  [ SYNSEM [ PUNCTUATED -,
             LOCAL [ CAT [ HEAD adv &
				[ MOD < [ MODIFIED notmod,
					  LOCAL [ CAT [ HEAD verb & [ MODIFIABLE + ],
							VAL [ SUBJ < [] >,
							      COMPS < > ] ],
						  CONT.HOOK #hook & 
						      [ INDEX.E.ASPECT durative ] ] ] > ],
			   VAL [ COMPS < >,
				 SUBJ < >,
				 SPR < > ],
			   POSTHEAD - ],
		     CONT [ HOOK #hook, RELS <! !> ] ],
	     NON-LOCAL.SLASH 0-dlist ] ].


;;zzf 2016-10-24 why is adv's HOOK the same as the one it modifies? In ERG, ARG1 of adv points to INDEX of the modified

deg-int-adv-vp-pre := basic-int-adv-lex &
"""
We are adding the ability for degrees specifiers to be itself degree specified to allow sentences like  He is very very very tall.  (we follow the ERG) 
We could say SPR < [] >  so there is only 1 thing there.... for now all SPR are degree specifiers in ZHONG.
"""
  [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < #mod & 
                                    [ LOCAL.CAT [ HEAD +vjr & [ MODIFIABLE + ],
						  VAL [ SUBJ < [] >,
					                COMPS < > ] ] ] >,
                         VAL [ SPEC < #mod & [ INTERJECTED - ] >,
			       SPR < [] >,
                               COMPS < > ],
                         POSTHEAD - ] ] ].


; deg-int-adv-vp-pre := int-adv-vp-pre &
;   [ SYNSEM.LOCAL [ CAT.VAL [ SPEC < [ LOCAL.CONT.HOOK.INDEX #ind ] >,
; 			     SPR < > ],
; 		   CONT.RELS.LIST.FIRST.ARG1 #ind ] ].

;   [ SYNSEM.LOCAL [ CAT.VAL [ SPEC < [ LOCAL.CONT.HOOK #hook ] >,
; 			     SPR < > ],
; 		   CONT.HOOK #hook ] ].

int-adv-v-pre :=  intersective-mod-lex & basic-icons-lex-item &
  [ SYNSEM [ PUNCTUATED -,
             LOCAL [ CAT [ HEAD adv & 
				[ MOD < lex-synsem & 
					[ LOCAL.CONT.HOOK #hook ] > ],
			   VAL [ COMPS < >,
				 SPR < >],
			   POSTHEAD - ],
		     CONT [ HOOK #hook,
			    RELS <! !> ] ],
	     NON-LOCAL.SLASH 0-dlist ] ].

;; SSH 2014-12-04: We do not use this type any longer
; adv-dur-v-pre := int-adv-v-pre & 
;  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [ LOCAL.CONT.HOOK.INDEX.E.ASPECT durative ] > ] ].

;; SSH 2014-09-03: To block overgeretation (e.g., *以前 以前 张三 很 老),
;; I added [MODIFIED notmod].
;; SSH 2014-12-09: For 狗 以前 一直 叫, [MODIFIED notmod] is deleted.
int-adv-s-pre := intersective-mod-lex & basic-icons-lex-item &
  [ SYNSEM [ L-PERIPH +,
             PUNCTUATED -,
	     LOCAL [ CAT [ HEAD adv &
				[ MOD < [ LOCAL [ CAT [ HEAD +vjp,
							POSTHEAD +,
							VAL [ SPR olist,
							      COMPS < > ] ],
						  CONT.HOOK #hook ] ] > ],
			   VAL [ COMPS < >,
				 SUBJ < >,
				 SPR < >],
			   POSTHEAD - ],
		     CONT [ HOOK #hook ] ],
	     NON-LOCAL.SLASH 0-dlist ] ].


int-adv-s-pre-no-rel := int-adv-s-pre & 
  [ SYNSEM.LOCAL.CONT.RELS <! !> ].

int-adv-s-pre-rel := int-adv-s-pre & 
  [ SYNSEM [ LOCAL.CONT.RELS <! #rel !>,
	     LKEYS.KEYREL #rel & [ ARG0 event ] ] ].


;; Postverbal adverbs 

int-adv-s-post := basic-int-adv-lex &
  [ STYLE robust,
    SYNSEM [ R-PERIPH +,
	     LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT [ HEAD +vj,
						  VAL [ SUBJ < >,
							COMPS < > ],
						  MC + & #mc ],
				      NON-LOCAL.SLASH 0-dlist ] >,
			 VAL [ COMPS < >,
			       SPEC < >,
			       SPR < >] ,
			 POSTHEAD +,
			 MC #mc ] ] ].

;; Type for negative adverbs.

;; SSH 2015-01-26: Why is [ MC + ] needed?
;; ZZF 2016-11-4: negation adverb also modifies adj，and it's scopal modifier, not SPR (therefore SPEC < >). Only degree adverbs are specifiers.
;; ZZF 2016-12-8: taking out "LIGHT +," from MOD, to allow "不 常 来", "不 太 喜欢"
neg-adv-lex := basic-scopal-adv-lex &
"""
Tentatively we are setting the MOD's COMP value to empty (< >) to avoid ambiguity on the level of attachment. 

FIXME:
For educational purposes, we want to block 不 before degree specifiers (e.g., 他 不 很 高 。). 
But it is not clear whether this is problematic in casual speech -- we might not want to block it altogether.
We experimented with setting the SPR to  <[ ]> (a list of length one) to make 不 select the adjective before the degree specifier. But this does not work:
Verbs come with empty specifiers (SPR < >). Adjectives come looking for a optional single specifier (SPR <[ ]>) that is their degree specifier.
Therefore, we can't use SPR to block the order in which 不 appears.

<ex>??? 他 不 很 高 。
<ex>他 不 高 。
<ex>他 很 不 高 。
<ex>他 很 不 好吃 。
<ex>你 不 知道 。


Let's say: Thre is a  the scopal BU could be used for 1,2,5 and then we could ave a lexical BU
Lexical BU would be a degree specifier...  and scopal BU does not take degree spc.

EVERYONE NOT HAPPY.  >>> 

If we have a non-scopal that REQUIRES a degree-SPR.  +  a scopal that IS a degree-SPR.
maybe a specl head-spr rule : the normal rule would be intersective; This would have to ALSO allow to be specified FURTHER 
the special one would be scopal and allow BU

"""
  [ SYNSEM.LOCAL.CAT [ VAL [ COMPS < >,
			     SPEC < > ],
		       HEAD.MOD < [ LOCAL.CAT [ HEAD +vj,
						VAL [SUBJ cons,
						     COMPS < >] ] ] > ] ].



;; Moveable scopal adverbs -- Edited 8-21-09 1:11PM
;; Note: perhaps temporal adverbs are int-adv-lex (S or VP)

scop-adv-lex  := basic-scopal-adv-lex &
"""
This is basically restricted to VPs or Sentences.  [FIXME?]
Nothing is said about the subject (only COMPS).
Even though the name is not clear, it is pre-head (which makes the existence 
of a 'scop-adv-prehd-lex' somewhat confusing -- should be FIXME).
This correctly predicts that there are some adverbs that can appear 
both before pre-VP or pre-S. E.g. 可能
<ex> 可能 他 不 会 去 。
<ex> 他 可能 不 会 去 。
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT [ HEAD verb,
                                                VAL.COMPS < > ] ] >,
               VAL.COMPS < >,
               POSTHEAD - ] ].

scop-adv-s-prehd-lex := basic-scopal-adv-lex  &
"""
This is a subtype of scop-adv-lex strictly for sentences.
This predicts that some adverbs can only appear as pre-head of a sentence.
This is (at the very least) necessary to support certain mal-rules such 
as incorrect use of 也. 也 cannot appear to the left of the subject. 
SUBJ < > also happens in for extracted subjects, so we need to block it.
I tried to do that by asserting NON-LOCAL.SLASH.LIST < > (is empty)
Not sure if this is the best way. [FIXME][FCB-CHECK].
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT [ HEAD +vj,
                                                VAL [COMPS < >,
						     SUBJ < > ] ],
				    NON-LOCAL.SLASH.LIST < > ] >,
               VAL.COMPS < >,
               POSTHEAD - ] ].



;; SSH 2014-11-10: 都 (dou) 
;; Added [SUBJ < [] >] for * 三 只 猫 都 我们 不 追赶 。
;; Added [COMPS < >] for blocking 我们 [[都 喜欢] 烟草] 
;; ZZF 20161115: removing SPR < >  as the head may not have degree specifier saturated.
scop-adv-prehd-lex := basic-scopal-adv-lex &
"""
This rule allows adverbs to modify both VP and APs, but it requires that the subject is 
not yet satisfied.
The name of this rule, however, clashes with 'scop-adv-lex', as they are both pre-head.
This should be FIXME. 
This correctly predicts that there are some adverbs that must come between the subject 
and the VP/AP. E.g. 也 and 都
However there is some necessary order for some of these adverbs that is not yet captured.
<ex> 他 也 会 去 。
<nex> 也 他 会 去 。
<ex> 他们 都 会 去 。
<nex> 都 他们 会 去 。
"""
  [ SYNSEM [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT [ HEAD +vj,
						  VAL [ SUBJ < [] >, 
							COMPS < >
							] ] ] >,
			 VAL [ COMPS < >,
			       SPEC < > ],
			 POSTHEAD - ],
	     MODIFIED notmod ] ].


scop-adv-posthd-lex := basic-scopal-adverb-lex &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT [ HEAD +nv,
						VAL.SPR < > ] ] >,
		       VAL.COMPS < >,
		       POSTHEAD + ] ].






tag-adv-lex := scop-adv-posthd-lex &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT [ HEAD verb,
                                                  VAL.SUBJ < > ],
                                      NON-LOCAL.SLASH 0-dlist ] >,
                         VAL.SPR < unexpressed > ],
         NON-LOCAL.SLASH 0-dlist ] ].








interjection-lex := basic-scopal-adv-lex &
"""
Lexical type for interjections (which may appear at the beginning or the end of a sentence).
Interjections are being treated as sentencial adverbs. (e.g. 哎. 哦, 嗯, 噢, 哎呀)
The valus of HEAD and VAL inside MOD ensured that only sentences can be modified by these.

This does not specify the value for POSTHEAD. There are two children of this type that 
further restrict lexical entries that to be strictly pre-head or post-head.

[FIXME] Try to understand and document [PUNCTUATED na-or--] [L-PERIPH -] [R-PERIPH +]


Added noun as possible value to the HEAD to allow sentences like:
<ex> 外婆 ， 您好 ！
These sentences are then licensed by a strict root condition through 'np-voc-adp'.


[NONSUBJ +] to prevent ambiguity in the attachment of interjections. Without it, it could attach both to the NP before becoming a subject, and to the full sentence. 


[INTERJECTED +] makes anything modified by an interjection also [INTERJECTED +].
"""
  [ SYNSEM [ L-PERIPH +,
	     INTERJECTED +,
	     LOCAL.CAT [ HEAD.MOD < [ L-PERIPH -,
				      R-PERIPH +,
				      INTERJECTED +,
; 				      PUNCTUATED na-or--,
				      LOCAL.CAT [ HEAD +nvj,
						  NONSUBJ +,
						  VAL [ SUBJ <>,
							COMPS <> ] ],
				      NON-LOCAL [ SLASH 0-dlist,
						  REL 0-dlist,
						  QUE 0-dlist ] ] >,
			 VAL [ SUBJ < >,
                               COMPS < >,
			       SPEC < > ] ] ] ].

interjection-prehd-lex := interjection-lex &
"""
Strictly pre-sentence interjections.

[PUNCTUATED na-or--] on pre-sentence interjections delays the punctionation attachment to the end (i.e. highest).
"""
  [ SYNSEM.LOCAL.CAT [ POSTHEAD -,
		       HEAD.MOD < [ PUNCTUATED na-or-- ] > ] ].

interjection-posthd-lex := interjection-lex &
"""
Strictly post-sentence interjections.
"""
  [ SYNSEM.LOCAL.CAT.POSTHEAD + ].






;; Conjunctions
conj-lex :+
  [ SYNSEM.PUNCTUATED - ].

conj-x-lex := conj-lex &
  [ SYNSEM.LKEYS.KEYREL [ L-INDEX ref-ind,
                          R-INDEX ref-ind ] ] . 

conj-e-lex := conj-lex &
  [ SYNSEM.LKEYS.KEYREL [ L-INDEX event,
                          R-INDEX event ] ]. 

subord-conj-lex  := basic-subord-conjunction-lex & basic-icons-lex-item &
"""
This takes a sentence (with empty satisfied) as complement. And expects to modify (MOD) something with empty COMPS (but it says nothing about the SUBJ of what it modifies, this might be incorrect).


[FIXED] This was expecting something headed by a verb as complement, and saying that it can only modify something also headed by a verb. This sounds profoundly wrong...  conjunctions can also take adjectival predicate sentences! This is either too constrained, or we need to create various subtypes.

LMC: Changed this to +vj (at least), let's see how bad it gets in ambiguity.

[FIXME] conj_-_sub-pre_le  can take both punctuated and non-punctuated things, if we block taking punctuated things, we can force punctuation to attach after, seems reasoable and saves spurious ambiguity

"""
  [ ARG-ST < #comps >,
    SYNSEM [ PUNCTUATED -,
             LOCAL [ CAT [ VAL [ SUBJ < >,
                                 COMPS < #comps &
;                                         [ LOCAL.CAT [ HEAD verb,
                                        [ LOCAL.CAT [ HEAD +vj,
                                                      VAL [ SUBJ < >,
                                                            COMPS < > ],
                                                      MC - ],
                                          OPT - ] >,
                                 SPR < >,
                                 SPEC < > ],
                           HEAD adv &
                                [ MOD < [ LOCAL scopal-mod &
;                                                 [ CAT [ HEAD verb,
                                                [ CAT [ HEAD +vj,
                                                        VAL.COMPS < > ] ] ] > ] ],
                     CONT.RELS <! #rel !> ],              
              LKEYS.KEYREL #rel ] ].

;;ZZF 6-4-2016 adding in "POSTCOMP -", assuming (conj+comp_v) modifying v
subord-conj-pre-lex := subord-conj-lex &
   [ SYNSEM.POSTCOMP - ].

subord-conj-pre-preh-lex := subord-conj-pre-lex &
   [ SYNSEM.LOCAL.CAT.POSTHEAD - ].

;;for comp_v+conj, e.g. "... 以后"
subord-conj-post-lex := subord-conj-lex &
   [ SYNSEM.POSTCOMP + ].


;;; Auxiliaries

subj-raise-aux := aux-lex & trans-first-arg-raising-lex-item & verb-no-spr-item &
  [ SYNSEM [ PAREN -,
	     LOCAL [ CAT.VAL [ SUBJ < #subj >,
			       COMPS < #comps >,
			       SPR < > ],
		     CONT.HOOK.XARG #xarg ] ],
    ARG-ST < #subj &
             [ LOCAL [ CONT.HOOK.INDEX #xarg,
                       CAT [ VAL [ SPR < >,
                                   COMPS < > ],
                             HEAD noun ] ] ],
             #comps &
             [ LOCAL.CAT [ VAL [ SUBJ < unexpressed >,
                                 COMPS < > ],
                           HEAD verb ] ] > ].

subj-raise-aux-with-pred := subj-raise-aux & norm-sem-lex-item & 
                            trans-first-arg-raising-lex-item-1.

v_aux-aux-lex := subj-raise-aux-with-pred &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST [ LOCAL.CAT [ MC +,
						     HEAD.FORM finite ],
                                         OPT -],
                   CONT.HOOK.INDEX.SF prop-or-ques ] ].

imperative-aux-lex := subj-raise-aux-with-pred &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST [ LOCAL.CAT.HEAD.FORM finite,
                                         OPT - ],
                   CONT.HOOK.INDEX.SF comm ],       
    ARG-ST.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PERNUM 2nd ].

cop-verb-lex :=  transitive-verb-lex & verb-no-spr-item &
"""

The [COP +] feature identifies 是 as a copula, which is useful to use in constraints of other rules. For example, [COP +] can't be used in VV(rslt) constructions.
<ex>他 是 张三

Sentences like:
<ex> 我 就 是 。
Shows that the previous [ OPT - ] on COMPS was incorrect.
 
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.COP +,
                       VAL [ SPR < > ] ] ].

cop-verb-cpsubj-lex :=  main-verb-lex & basic-two-arg-no-hcons &
                        basic-icons-lex-item & verb-no-spr-item &
   [ SYNSEM [ LOCAL.CAT [ HEAD.COP +,
                          VAL [ SUBJ < [ LOCAL.CAT.HEAD +vjp & [EMPTY -] ] >,
                                COMPS < #comp & canonical-synsem &
                                        [ LOCAL.CAT [ VAL [ SPR < >,
                                                            COMPS < > ],
                                                      HEAD noun ],
                                          NON-LOCAL.SLASH 0-dlist ] > ] ],
          LKEYS.KEYREL [ ARG1 #arg1,
                 ARG2 #ind2 ] ],
     ARG-ST < [ LOCAL.CONT.HOOK.LTOP #arg1 ],
          #comp & [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind2 ] > ].

cop-verb-cpcomp-lex := basic-one-arg & verb-lex & basic-verb-lex & basic-icons-lex-item & verb-no-spr-item &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ < >,
                                 COMPS #comps ],
                           HEAD.COP + ],
                     CONT [ HOOK [ LTOP #lbl,
                                   INDEX #event ],
                            RELS <! #keyrel !>,
                            HCONS <! qeq & [ HARG #arg1,
                                             LARG #cltop ] !> ] ],
             LKEYS.KEYREL #keyrel &
                   [ LBL #lbl,
                     ARG0 #event,
                     ARG1 #arg1 ] ],
    ARG-ST #comps &
           < [ LOCAL [ CAT [ VAL [ SUBJ < >,
                                   SPR < >,
                                   COMPS < > ],
                             HEAD verb ],
                       CONT.HOOK.LTOP #cltop ] ] > ].

focus-icons-norm-lex-item := one-icons-lex-item &
"""adding in focus information into ICONS for SHIDE emphatic structures other than scoping modifiers.
"""
 [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #empind ],
                                  [ LOCAL.CONT.HOOK.INDEX #clind ] > ,
                  CONT [ HOOK.INDEX #clind,
                         ICONS <! focus & [ IARG1 #clind,
					  IARG2 #empind ] !> ] ] ].

focus-icons-scop-lex-item := one-icons-lex-item &
"""adding in focus info for emphasizing scoping adverbs. The scopal adverb's INDEX is the same as its MOD's, which leads to ICONS having the same value for IARG1/2. Using LKEYS.KEYREL.ARG0 avoids this problem. It only works for word level as LKEYS is not visible at phrase level, therefore can't be used for BU+AUX.
"""
 [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LKEYS.KEYREL.ARG0 #empind ],
                                  [ LOCAL.CONT.HOOK.INDEX #clind ] > ,
                  CONT [ HOOK.INDEX #clind,
                         ICONS <! focus & [ IARG1 #clind,
					  IARG2 #empind ] !> ] ] ].

shi-emph-lex := no-rels-hcons-lex-item & verb-no-spr-item &
"""The first item on COMPS is the emphasized constituent. 
"""
 [ SYNSEM [ PUNCTUATED -,
            LOCAL.CAT [ HEAD verb & [ COP + ], 
                        VAL [ SPR < >,
                              COMPS < [ OPT - ],
                                      [ LOCAL.CAT [ HEAD postp-comp & [ MOD < synsem > ],
                                                    VAL.COMPS < > ],
                                        OPT - ] > ] ] ] ].

shi-other-dep-lex := shi-emph-lex & basic-three-arg-no-hcons &
 [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < #subj & [ LOCAL.CAT.HEAD noun ] >,
                          COMPS < synsem,
                                  [ LOCAL.CAT.HEAD.MOD < #subj > ] > ] ].
             
shi-mod-dep-lex := shi-other-dep-lex & 
"""
<ex>他 是 一定 会 哭 的
INDEX and LTOP of the modified is the same as those of DeP, which are the same as those of the embedded VP in DeP.
ARGS: list of children of rule. ARG-ST: subj + comps. XARG for the thing that pp or advp is modifying.
"""
 [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD +rp & [ MOD < [ LOCAL.CONT.HOOK [ INDEX #clind,
                                                                                     LTOP #ltop ] ] > ] ],
                                [ LOCAL.CONT.HOOK [ INDEX #clind,
                                                    LTOP #ltop ] ] > ].

shi-mod-int-dep-lex := shi-mod-dep-lex & focus-icons-norm-lex-item &
"""
<ex>他 是 昨天 哭 的
"""
 [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.MOD < [ LOCAL intersective-mod ] > ],
                                synsem > ].

shi-mod-scop-dep-lex := shi-mod-dep-lex & focus-icons-scop-lex-item &
"""
<ex>他 是 绝对 会 完成 任务 的
<ex>他 是 绝对 哭 了 的
<ex>他 是 绝对 不 会 完成 任务 的
"""
 [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.MOD < [ LOCAL scopal-mod ] > ],
                                synsem > ].

shi-aux-dep-lex := shi-other-dep-lex & focus-icons-norm-lex-item &
"""linking aux and verb up. This leads to the correct qeq result.
<ex>他 是 会 哭 的
<ex>他 是 不 会 哭 的
"""
 [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD verb & [ AUX + ],
                                              VAL.COMPS < [ LOCAL.CONT.HOOK [ INDEX #vind,
                                                                              LTOP #ltop ] ] > ] ],
                                [ LOCAL.CONT.HOOK [ INDEX #vind,
                                                    LTOP #ltop ] ] > ].



shi-subj-dep-lex := shi-emph-lex & basic-two-arg-no-hcons & focus-icons-norm-lex-item &
"""
<ex>是 他 完成 任务 的
<ex>是 我 邀请 他 来 的
How to indicate then there can be a slashed argument in DeP which is object?
"""
 [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < >,
                          COMPS < #comp1 & 
                                  [ LOCAL [ CAT.HEAD noun,
                                            CONT.HOOK.INDEX #subj-ind ] ],
                                  #comp2 & 
                                  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #subj-ind ] > ] > ],
   ARG-ST < #comp1, #comp2 > ].


de-4shi-lex := raise-sem-lex-item & no-icons-lex-item & norm-zero-arg &
"""Special DE used in ShiDe structure for alternative location of object of a transitive verb.

Feature CH + means this COMP is before the head, CH - means it's after the head.

<ex>他 是 昨天 完成 的 任务

Currently using OPT+ to stop this DeP from being treated as an actual modifier for noun. In rule head-adj-int-phrase, constraint [ OPT na-or-- ] is used to exclude this DeP.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD postp-comp &
	                    [ MOD < #subj & [ OPT + ] > ],
		        VAL [ SPR < >,
                              SPEC < >,
                              SUBJ < >,
			      COMPS < [ LOCAL [ CAT [ HEAD verb & [ COP - ],
                                                      VAL [ SUBJ < #subj >,
                                                            COMPS < #obj > ] ] ],
                                        CH +, 
                                        OPT - ],
                                      #obj & [ LOCAL.CAT.HEAD noun,
                                               CH -,
                                               OPT - ] > ] ] ].




subj-drop-verb-lex := lex-item.
no-subj-drop-verb-lex := lex-item.

;;
obj-drop-verb-lex := lex-item.
no-obj-drop-verb-lex := lex-item.

;;; Determiners
;;; SPEC is non-empty, and already specified by basic-determiner-lex.


;; SSH 2015-04-21: Now [每 [[一 只] 猫]] is the correct form, and the relation 
;; between [[一 只] 猫] is meas-np-phrase
determiner-lex := basic-determiner-lex & basic-zero-arg &
  [ SYNSEM [ PAREN -,
             PUNCTUATED -,
	     LOCAL [ CAT.VAL [ SPR < >,
			       SUBJ < >,
			       SPEC < [ LOCAL.CAT.HEAD.MEASURE na-or-+,
                                        INTERJECTED - ] > ],
		     CONT.RELS <! relation !> ],
	     NON-LOCAL.SLASH 0-dlist ] ].

determiner-cls-lex := determiner-lex &
"""

The SORT of determiner taking classifiers will be SORT of their classifiers.
This is important for pumping rules making time adjuncts from bare determiner phrases (e.g. 每天 or 每次).
"""
  [ SYNSEM.LOCAL [ CAT.VAL [ COMPS < [ LOCAL [ CAT.HEAD classifier,
					       CONT.HOOK [ INDEX #index & [SORT #sort],
							   LTOP #ltop ] ],
				       OPT - ] >,
			     SPEC < [ LOCAL.CONT.HOOK.LTOP #ltop ] > ],
		   CONT.HOOK [INDEX #index & [SORT #sort] ] ] ].


super-determiner-nocls-lex := determiner-lex &
"""
This is the supertype for interrogative and non-interrogative determiners that do not allow the use of classifiers.

This level exists because we currently want to say that non-interrogative determiners are [SORT nontime-s] -- which seems to hold true, and spares a lot of ambiguity. But interrogative determiners cannot have this restriction because of 什么, e.g. '什么 时候'.

By default, determiners check the SORT type of the classifiers they take when they are being pumped into a NP. When they do not take classifiers, the default assumption is that they CANNOT be pumped into a time adverbial.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < > ] ].


determiner-nocls-lex := super-determiner-nocls-lex &
"""
By default, determiners check the SORT type of the classifiers they take when they are being pumped into a NP. When they do not take classifiers, the default assumption is that they CANNOT be pumped into a time adverbial.

"""
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.SORT nontime-s ] ].




;; SSH 2015-04-16 discourse status (definitesness)
; ---------------------------------------
;           | cmn             | yue
; ---------------------------------------
; DEM-CL-N  | uniq-fam-active (definite)
; NUME-CL-N | type-id (indefinite)
; CL-N      | type-id         | active-or-less ((in)definite)
; N         | active-or-less  | type-id 
; ---------------------------------------
demons-determiner-lex := determiner-cls-lex & 
 [ SYNSEM.LOCAL.CONT.HOOK.INDEX.COG-ST uniq+fam+act ].
prox_demons-determiner-lex := demons-determiner-lex.
dist_demons-determiner-lex := demons-determiner-lex.

demons-det-nocls-lex := super-determiner-nocls-lex & 
 [ SYNSEM.LOCAL.CONT.HOOK.INDEX.COG-ST uniq+fam+act ].
prox_demons-det-nocls-lex := demons-det-nocls-lex.
dist_demons-det-nocls-lex := demons-det-nocls-lex.

wh-determiner-item := lex-item &
 [ SYNSEM [ LKEYS.KEYREL [ ARG0 #ind ],
            NON-LOCAL.QUE 1-dlist & <! #ind !>] ].

wh-determiner-lex := determiner-cls-lex & wh-determiner-item.

wh-determiner-nocls-lex := super-determiner-nocls-lex & wh-determiner-item &
"""

This type is currently only for 什么 (and orthographic variants). And since 什么 also exists as a pronoun, we want to block the case where the determiner gets pumped to the equivalent of a pronoun. 
The rule '0-nom-d' will then have to make sure [OPT +] is enforced before pumping rules. 

We need these to be able to join with time nouns, '什么 时候'.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [OPT -] > ].


;;; Markers

;; SSH 2014-09-03: To block *[一直 了], I added [HEAD verb].
;; SSH 2014-12-04: Now, 了/着/过 are markers, not adverbs, following
;; Zhenzhen's argument.
;; SSH 2014-12-09: To prevent *[[都 叫] 了], [MODIFIED notmod] is added. 
aspect-markers := raise-sem-lex-item & no-icons-lex-item &
"""


this is used by 'comp-marker' to join aspect markers to verbs 
"""
  [ SYNSEM [ PAREN -,
             PUNCTUATED -,
	     LOCAL [ CAT [ HEAD marker & [ MOD <> ],
			   VAL [ COMPS < lex-synsem & 
					 [ MODIFIED notmod,
					   LOCAL [ CAT [ HEAD +vp & [ AUX - ],
                                                         VAL.SUBJ < [] > ] ] ] >,
				 SUBJ < >,
				 SPEC < >,
				 SPR < > ],
			   POSTHEAD + ] ],
	     NON-LOCAL [ SLASH 0-dlist & <! !>,
                         REL 0-dlist & <! !>,
                         QUE 0-dlist & <! !> ] ] ].

 
part-lex-item := raise-sem-lex-item & basic-one-arg & no-icons-lex-item &
  [ SYNSEM [ PAREN -,
             PUNCTUATED -,
	     LOCAL.CAT [ HEAD marker & [ MOD < > ],
			 VAL [ SPR < >,
			       SUBJ < >,
			       COMPS < #comp > ] ] ],
    ARG-ST < #comp &
             [ PUNCTUATED -,
	       INTERJECTED na-or--,
	       LOCAL.CAT [ MC +,
                           VAL [ SUBJ < >,
                                 COMPS < > ] ] ] > ].

spart-lex-item := part-lex-item &
  [ ARG-ST < [ LOCAL.CAT.HEAD +vjp ] > ].


;; NE
frag-qpart-lex-item := part-lex-item & nonque-item &
"""
<ex> 你 呢  ？
"""
  [ ARG-ST < [ LOCAL [ CAT.HEAD noun,
                       CONT.HOOK.INDEX.SF ques ] ] > ].

qpart-lex-item := spart-lex-item & nonque-item &
"""
Subtype for question particles. Constrains SF to ques directly. MA.

<ex> 你 是 学生 吗 ？

Added [SUBJ < >] and [SLASH 0-dlist] to force it being optional or filled before it attaches.
"""
  [ STYLE robust,
    SYNSEM [ SPART ma,
             PUNCTUATED -,
	     LOCAL [ CAT.VAL [ COMPS < [ SPART not-ma,
					 LOCAL.CAT.VAL [SPR olist,
							SUBJ < >],
					 NON-LOCAL [QUE 0-dlist,
						    SLASH 0-dlist] ] >  ],
		     CONT.HOOK.INDEX.SF ques ] ] ].




;#|******** A-NOT-A QUESTIONS ******** 
;;  WWJ: A-not-A Interrogatives 
;; 	Update (2015-02-14): Implemented AB-not-A(B)
;;	Update (2015-02-13): Added general structure, and individual structures for BASIC and CONTRACTED forms
;;|#

;; ***** Basic + Contracted A-not-A
;; SSH 2015-04-22: added ICONS, SUBJ <>
;; ZZF 20161116: added SPEC < > as they are not specifiers, SUBJ <[]> for verb.
a-not-a-adv-lex := raise-index-mod-lex-item & single-rel-lex-item & 
		   scopal-mod-lex & one-icons-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adv & [ MODIFIABLE -,
					MOD < lex-synsem &
					      [ ASPECTED -,
                                                OPT -,
						LOCAL [ CAT [ HEAD +vjrp & [ MODIFIABLE -,
									     PRED-KEY #key ],
							      VAL [ COMPS #comps,
								    SUBJ #subj & < [ ] > ] ],
							CONT.HOOK [ ICONS-KEY #ikey,
								    INDEX #idx & [ E.ASPECT non-aspect ] ] ],
						LKEYS.KEYREL.PRED #pred ] > ],
			   VAL [ SUBJ < >,
                                 SPEC < >,
				 COMPS < lex-synsem &
				       [ SPART no-spart,			
					 ASPECTED -,
                                         OPT -,		 
					 LOCAL [ CAT [ HEAD +vjrp & [ MODIFIABLE -,
								      PRED-KEY #key ],
						       VAL [ COMPS #comps,
							     SUBJ #subj ] ],
						 CONT.HOOK.INDEX #idx & [ E.ASPECT non-aspect ] ],
					 NON-LOCAL.SLASH 0-dlist,
					 LKEYS.KEYREL.PRED #pred ] > ],
			   POSTHEAD + ],
		     CONT [ HOOK.INDEX  [ SF ques,
					  E.ASPECT non-aspect ],
			    ICONS <! focus & #ikey & [ IARG2 #idx ] !> ] ],
	     NON-LOCAL.SLASH 0-dlist,
	     LKEYS.KEYREL event-relation, 
	     SPART no-spart ] ].

;;ZZF 20161116 idendify HEAD to have stricter contraints, eg.g. the two Vs must be the same V.
a-not-a-basic-adv-lex := a-not-a-adv-lex &
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS < [ LOCAL.CAT.HEAD #head ] >,
		       HEAD.MOD < [ LOCAL.CAT.HEAD #head, 
				    BOUND - ] > ] ].

a-not-a-contracted-adv-lex := a-not-a-adv-lex &
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS < [ LOCAL.CAT.HEAD.CHAR [ FCHAR #fstr, 
							   LENGTH more-than-one ] ] >,
		       HEAD.MOD < [ LOCAL.CAT.HEAD.CHAR [ WCHAR #fstr,
							  LENGTH one ] ] > ] ].

;#|***** AB-NOT-A(B) ******
; WJ (2015-02-14): This covers the AB-not-A(B) structure, where B is the object.
; 		 Unlike the regular ADV 不, which is [ [不 [喜欢] ] 狗 ], 
; 		 for AB-not-AB, the VPs are modified by 不 as a single unit: [ 不 [ [ 喜欢 ] 狗 ] ]

; 		 张三 喜欢 狗 不 喜欢 狗
; 		 张三 喜欢 狗 不 喜欢
; 		*张三 喜   狗 不 喜欢
; 		*张三 喜欢 狗 不 喜
; 		*张三 喜欢 不 喜 狗

; WJ (2015-02-15): Added phr-synsem
; WJ (2015-02-20): Added CONT.HOOK.INDEX.SF ques to prevent IMPER
; WJ (2015-03-04): Added SUBJ < [] > to HEAD.MOD to block [ [ 张三喜欢狗 ]-S [ 不 [喜欢 狗]-VP ]-ADV
; WJ (2015-03-16): 1) Added HEAD.MODIFIABLE - to COMPS and MOD to block the A-elements from being modified 
; 									(Eg: * 张三 很 喜欢 不 很 喜欢 狗)
; 		 2) Added E.ASPECT non-aspect to COMPS and MOD to block ASP-了 from modifying elements
;*********************** |#

;; SSH 2015-04-22: added [MC + ]
;; ZZF 20161116: added SPEC < > as they are not specifiers, SUBJ <[]> for verb.
ab-not-ab-adv-lex := raise-index-mod-lex-item & single-rel-lex-item & 
		     scopal-mod-lex & one-icons-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ < >,
                                 SPEC < >,
				 COMPS < phr-synsem &
				       [ LOCAL [ CAT [ MC +,
						       HEAD verb & [ CHAR.WCHAR #wstr,
								     MODIFIABLE - ],
                                                       VAL.SUBJ < [ ] > ], 
						 CONT.HOOK.INDEX [ SF ques,
								   E.ASPECT non-aspect ] ], 
					 NON-LOCAL.SLASH 0-dlist,
                                         OPT - ] > ],
			   POSTHEAD +,
			   HEAD adv & [ MODIFIABLE -,
					MOD < phr-synsem &
					      [ OPT -,
                                                LOCAL [ CAT [ MC +,
							      HEAD verb & [ CHAR [ WCHAR #wstr,
                                                                                   LENGTH more-than-one ],
									    MODIFIABLE - ],
							      VAL [ SUBJ < [ ] > ] ],
							CONT.HOOK [ ICONS-KEY #ikey,
								    INDEX #idx & [ SF ques,
										   E.ASPECT non-aspect ] ] ] ] > ] ],
		     CONT [ HOOK.INDEX.SF ques,
			    ICONS <! focus & #ikey & [ IARG2 #idx ] !> ] ],
	     NON-LOCAL.SLASH 0-dlist,
	     LKEYS.KEYREL event-relation ] ].


;; WWJ (2015-02-08): These sub-variants are supplementary definitions for 不, which blocks 有 不 有
;; I added the EXISTV feature for this; not sure if this is in line with standard practices...
;; Update (2015-02-13) : Split into three, BASIC, CONTRACTED and AB-not-A(B), inheriting from the structures above

a-not-a-bu-basic-adv-lex := a-not-a-basic-adv-lex &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD.EXISTV - ] > ] ] ] ]. 

a-not-a-bu-contracted-adv-lex := a-not-a-contracted-adv-lex &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD.EXISTV - ] > ] ] ] ].

ab-not-ab-bu-adv-lex := ab-not-ab-adv-lex &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD.EXISTV - ] > ] ] ] ].

;;|# ******** END OF A-NOT-A QUESTIONS ******** #|



+nvcdmo :+
"""
LMC: This was not signed, I wished there was a bit more info.
This grammar includes head-modifier rules.  To keep
out extraneous parses, constrain the value of MOD on
various subtypes of head.  This may need to be loosened later.
This constraint says that only adverbs, adjectives,
and adpositions can be modifiers.
"""
  [ MOD <> ].


;; Adjectives

basic-adjective-lex :+ basic-one-arg & basic-icons-lex-item &
  [ SYNSEM [ PAREN -,
             PUNCTUATED - ] ].

basic-attr-adj-lex := basic-int-mod-adj-lex & 
  [ SYNSEM [ PUNCTUATED -,
             LOCAL [ CAT [ HEAD.MOD < [ LOCAL [ CAT.HEAD noun,
						CONT.HOOK.INDEX #index ] ] > ],
		     CONT [ HOOK.INDEX #arg0,
			    RELS <! #rel !>,
			    ICONS <! !> ] ], 
	     LKEYS.KEYREL #rel & 
		   [ ARG0 #arg0, 
		     ARG1 #index ] ] ].

attr-adj-lex := basic-attr-adj-lex &
  [ SYNSEM.LOCAL.CAT [ POSTHEAD -,
		       HEAD.MOD < [ LOCAL.CAT.VAL.SPR < [] > ] >,
		       VAL [ COMPS < >,
			     SPR < >,
			     SUBJ < > ] ] ].

attr-adj-posthd-lex := basic-attr-adj-lex &
"""
There was a constraint making bare-np or other SPR releasing rules
to apply BEFORE any posthead adjetives: 
HEAD.MOD < [ LOCAL.CAT.VAL.SPR < > ]
However, in the realm where we treat 们 as such a modifier, then this
is not true anymore.
When this was discovered, only a_-_bound-posthead_le was using this 
rule, so I don't think this will be a big problem.
"""
  [ SYNSEM.LOCAL.CAT [ POSTHEAD +,
		       ;;;HEAD.MOD < [ LOCAL.CAT.VAL.SPR < > ] >,
		       VAL [ COMPS < >,
			     SPR < >,
			     SUBJ < > ] ] ].

basic-pred-adj-lex := basic-adjective-lex & no-hcons-lex-item &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ PRED-KEY #key ],
		     CONT [ HOOK [ LTOP #lbl, 
				   INDEX #arg0 ],
			    RELS <! #rel !> ] ],
	     LKEYS.KEYREL #rel & [ LBL #lbl,
				   PRED #key,
				   ARG0 #arg0 ] ] ].

pred-adj-lex := basic-pred-adj-lex &
"""
This is the main type for predicative adjectives. In principle, these ought to be able to server as predicates without a degree specifier (e.g. 很) but this construction is marked as comparative/constrastive. E.g.
她 漂亮。  She is more beautiful.



ZZF FB LMC 2016-2-24 SPR OPT changed from - to bool to allow adj predicate without specifier (adv) 姑娘　漂亮 ;
2016-4-20 taking out linking of NON-LOCAL.SLASH with that of its SUBJ

2021.01.27 -- LMC and FCB put back the linking of NON-LOCAL.SLASH with its SUBJ. We need to do a regression test. This was to remove bad analysis with optional subjects in relative clauses of Adjectives.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MOD <> ],
			   VAL [
; 			         SPR < [ LOCAL [ CAT [ HEAD adv,
; 						       VAL.SPEC < [ LOCAL.CAT.HEAD adj ] > ],
; 						 CONT.HOOK.LTOP #lbl ],
; 					 OPT bool ] >,
				 SUBJ < [LOCAL [CAT [HEAD +nv, 
						     VAL.SPR < > ],
						CONT.HOOK.INDEX #index &
						    [ SF prop-or-ques ] ],
					 NON-LOCAL.SLASH  #slash
					 ] >,
				 COMPS < > ] ] ],
	     NON-LOCAL.SLASH  #slash,
	     LKEYS.KEYREL.ARG1 #index ] ].



; LMC 2021.01.26
; In the literature there is a lot of discussion of multiple classification of
; adjectives concerning their gradability (which will, in turn directly restrict
; the degree modifiers it can take.
; In the context of iTELL, we also want a fine grained control of degree-specifier
; usage, to be able to block adjectives that would generally require them from
; adjectives or adjective-like constructions that do not (e.g. idioms). 
; We need at least one type of ADJ where SPR are not expected 

pred-adj-nospr-lex := pred-adj-lex &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ SPR < > ] ] ] ] ].
		      
pred-adj-optspr-lex := pred-adj-lex &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ SPR < [ LOCAL [ CAT [ HEAD adv,
						       VAL.SPEC < [ LOCAL.CAT.HEAD adj ] > ] ],
					 OPT bool ] > ] ] ] ] ].

pred-adj-spr-lex := pred-adj-optspr-lex &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ SPR < [ OPT - ] > ] ] ] ] ].






;; DPF 2011-06-17 - For now, we attach the degree specifier higher than any
;; complements, even though this seems counter-intuitive, especially compared
;; to the structure for adverbs with degree specifiers.  Maybe
;; FIX? later
s-comp-adj-lex := basic-pred-adj-lex &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < >,
			   VAL [ SUBJ < >,
				 SPR < [ LOCAL [ CAT [ HEAD adv,
                                                       VAL.SPEC < synsem > ],
						 CONT.HOOK.LTOP #ltop ] ] >,
				 COMPS < [ LOCAL [ CAT [ VAL [ SUBJ < >,
							       SPR < >,
							       COMPS < > ],
							 HEAD verb ],
						   CONT.HOOK.LTOP #cltop ],
					   OPT - ] > ] ],
		     CONT.HOOK.LTOP #ltop ],
	     LKEYS.KEYREL.ARG1 #cltop ] ].



;; ZZF/SSH 2015-03-10: testing reduplicated forms of adjectives
adj-redup-lex := no-spr-no-spec-lex-item & 
 [ SYNSEM [ PAREN -,
            PUNCTUATED -,
	    LOCAL [ CAT [ HEAD adj & [ MOD <> ],
                          VAL [ SUBJ < [ LOCAL [ CAT [ HEAD +nv,
			                               VAL.SPR < > ],
						  CONT.HOOK.INDEX #arg1 &
                                                   [ SF prop-or-ques ] ],
					  NON-LOCAL.SLASH #slash ] >,
				 COMPS <> ] ] ],
	    NON-LOCAL.SLASH #slash,
	    LKEYS [ KEYREL arg1-relation & event-relation &
			   [ ARG1 #arg1 ] ] ] ].


adj-aabb-lex := adj-redup-lex & redup-lex-item.

adj-abb-lex := adj-redup-lex & basic-pred-adj-lex.


classifier := +jd
"""
This means that rules that have jd will also allow CLs to apply.
If there is a rule that will apply to both adjectives and determiners then it is expected that it will be applied to this. 
[FIXME] this is not ok, we should have a distinct head value for classifiers
e.g.     classifier := head
         classifier :+ 
         [ HON luk,
           GENERIC luk,
           CLASSIFIED luk ].
and then try to find the other features currently breaking the grammar.
""".
; sortal-cl := classifier.
; mensural-cl := classifier.


basic-classifier-lex := norm-ltop-lex-item & single-rel-lex-item & 
                        intersective-mod-lex & no-icons-lex-item &
"""
Classifiers currently have two ways of attaching to nouns:
1. by being taken as complements of determiners, creating a DP, and 
   attaching to Nouns as SPR-HEAD rule; 
2. By attaching directy to a noun through a MOD-HEAD rule, and then
   being pumped to a NP through the BARE-NP rule.

This is slightly unsatisfying, as it produces non parallel structures.
[[DT[(NUM)(CL)]]NP]   and   [ [(NUM)(CL)] NP]

Also, because of this, only the 2nd method passes the head-feature
[CLASSIFIED +] to the noun. Which is also not ok. [FIXME]




Scope of adjectival modification:

    一 大 箱 苹果 ≠ 一 箱 大 苹果   ('Measure' Words)
    # 一 大 颗 苹果 = 一 颗 大 苹果   ('Sortal' Classifier)  >>>>> Not sure if I accept this, Jenny doesn't accept modification on this CL
    一 大 个 苹果 = 一 个 大 苹果    = meaning is the same, 一 大 个 苹果 informal, 
                                      so we should reject and accept as robust only.  
                                    >>> the first one seems to have emphasis on the adj


    (一) 大 箱 的 苹果  ≠ 大 苹果   ('Measure' Words)
    (一) 大 箱 的 小 苹果  is also possible 


    (一) 大 个 的 苹果 = 大 苹果    ('Sortal' Classifier)      >>>>> Not sure if I accept this
   * (一) 大 个 的 苹果 ?>>>> with DE is not ok.
   (一) 大 个 苹果 ? >>>> and the meaning is confirmed to be the apples are Big


Chen and Sybesma (1998) and modification marker 的:
    Mass-noun classifiers (e.g. Units of measure, containers) can 
    insert 的 between them and the noun. Sortal-CLs cannot do the same.
 
     三 磅 的 肉    or    两 箱 的 书        but not:
    *八 头 的 牛    or   *九 根 的 尾巴
     三 年 的 辛苦   also OK



'Measure' Words Number requirement:


   *我们 需要  磅  肉  (the numeral is necessary)
   *我们 需要  磅 的 肉  (the numeral is necessary)
    我们 需要  买 磅  肉   >>>  this is ok, but it's a bit casual... same as CL

    我们 需要 dai(bring) 把 椅​子 (the numeral is NOT necessary, but casual)

    我 给 你 介绍 个 女朋友 (sortal, ok but casual, always 1)



Coordination

    # 两 杯 和 三 瓶 啤酒      a bit wierd.
    # 三 瓶 和 两 杯 啤酒      a bit wierd. （order matters, shoul dbe BIG to small)
    三 瓶 加 两 杯 啤酒     》》》 This is ok, must should be beer for both

    三 瓶 加 两 杯 啤酒    >>  must be the same 


    两 杯 和 三 扎 (zha1, jug) 的 啤酒

    两 只狗 和 三条狗



yi ge ban xiaoshi  === 1 and 1/2 hours
* yi ban ge  xiaoshi  === 1/2 hours   -- don't use 1
ban ge  xiaoshi  === 1/2 hours

yi xiang ban pingguo = 1 and 1/2 box of apple
ban xiang pinggyup = 1/2 box of apple

yi 公斤 ban pingguo = 1.5 kg of apples
  ban 公斤  pingguo = 0.5 kg of apples
*yi  ban 公斤  pingguo = 0.5 kg of apples  --- don't use 1


yi zhi ban ji = 1.5 chicken 
 ban zhi  ji = 0.5 chicken 

yi nian ban = 1.5 years
ban nian = half year



one and a half tree

yi fēn ban = 1.5 minutes 
yi fēn ban zhong = 1.5 minutes 
ban fen zhong = 0.5 minutes




Summary of structures:

Demostrative + Sortal-CL                              (那 张 是 我 的 桌子 。）
Demostrative + Numeral + Sortal-CL                    (那 两 张 是 我 的 桌子 。）
Demostrative + Numeral + Sortal-CL + Noun             (那 两 张 桌子 是 我 的 。）

(我 有 两 张 桌子 。)


 


Cls identifies the KEYS.KEY with the classified noun, to allow nouns 
to potentially select a range of classifiers (not implemented yet).
This clashes with the way selected complements are being selected 
(through KEYS.KEY). If we want to keep both pieces of info we could 
use KEYS.ALTKEY instead for classifiers.
"""
  [ SYNSEM [ PAREN -,
             PUNCTUATED -,
	     LOCAL [ CAT [ HEAD classifier & 
				[ KEYS.KEY #sense,
				  MOD < [ LOCAL [ CONT.HOOK [ INDEX #index,
							      LTOP #ltop ],
						  CAT [ HEAD noun & [ CLASSIFIED +,
								      KEYS.KEY #sense ],
							VAL.SPR < [] > ] ] ] > ], 
			   VAL [ SPR < [ LOCAL [ CAT [ VAL [ COMPS < >,
							     SUBJ < > ],
						       HEAD num & 
							   [ MOD < > ] ],
						 CONT.HOOK [ LTOP #ltop,
							     INDEX #index ]]]>,
				 SUBJ < >,
				 COMPS < > ],
			   POSTHEAD - ],
		     CONT.HOOK [ INDEX #index & ref-ind,
				 LTOP #ltop ] ],          
	     NON-LOCAL.SLASH 0-dlist,
	     LKEYS.KEYREL [ PRED #sense,
			    ARG1 #index ] ] ].

;; SSH 2015-04-16: classifier-lex is not differently constrained in cmn and yue.
;; The following OPT constraint moves into zhong/cmn.tdl
;classifier-lex := basic-classifier-lex &
;   [ SYNSEM.LOCAL.CAT.VAL.SPR < [ OPT - ] > ].
classifier-lex := basic-classifier-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX [COG-ST activ-or-less ] ] > ]. 



nontime-classifier-lex := classifier-lex &
"""
[FIXME]
This is currently a test to create bare CL phrases that can be turn into time adverbs. 
The goal would be to transform something like 三 点  (which is a short form for 三 点 钟) and allow it to be pumped into a time adverbial by virtue of [SORT time-s]
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX [SORT nontime-s ] ] > ]. 


time-classifier-lex := classifier-lex &
"""
[FIXME]
This is currently a test to create bare CL phrases that can be turn into time adverbs. 
The goal would be to transform something like 三 点  (which is a short form for 三 点 钟) and allow it to be pumped into a time adverbial by virtue of [SORT time-s]
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX [SORT time-s ] ] > ]. 


;; Add feature NONSUBJ to distinguish quantifiers which cannot appear alone
;; as subjects, but can appear without numeral in non-subj position.

;; SSH 2015-04-16: NONCOMP added (Generic nouns can be used only as subject.)
cat :+ [ NONSUBJ bool,
	 NONCOMP bool ].

classifier-quant-lex := basic-classifier-lex &
  [ SYNSEM.LOCAL.CAT.NONSUBJ + ].



num-adj-lex := single-rel-lex-item & basic-icons-lex-item &
"""
This is the main type for basic Numerals.
They have [HEAD num]. And the special head-feature [CARDINAL +].

Their semantics is somewhat special, using CARG in a similar way as named relations.

We want: the ARG0 of the thing it will specify over (SPEC) to be the same as ARG1 on the relation it introduces. 
"""
  [ SYNSEM [ PAREN -,
             PUNCTUATED -,
	     LOCAL [ CAT [ VAL [ COMPS < >,
				 SUBJ < >,
				 SPR < > ],
			   HEAD num & [ ; CARDINAL +,     ;TEST
					MOD < > ] ],
		     CONT [ HOOK [ LTOP #lbl, 
				   INDEX #index ],
			    RELS <! #rel !>,
			    HCONS <! !> ] ],
	     NON-LOCAL.SLASH 0-dlist,
	     LKEYS.KEYREL card-relation & #rel & [ LBL #lbl,
						   ARG1 #index ] ] ].



card-num-adj-lex:= num-adj-lex &
"""
This is a subtype for numbers that distinguishes between cardinal and noncardinal.

This is ultimately to support the distinction between 二 (noncard) and 两 (card). This is being used in the 'spr-head-cl' rule to require that only cardinal numbers be available to serve as specifiers for classifiers.  
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ CARDINAL + ] ] ] ] ].

noncard-num-adj-lex:= num-adj-lex &
"""
This is a subtype for numbers that distinguishes between cardinal and noncardinal.

This is ultimately to support the distinction between 二 (noncard) and 两 (card). This is being used in the 'spr-head-cl' rule to require that only cardinal numbers be available to serve as specifiers for classifiers.

As such, 二 would not be able to be the specifier of a classifier. 
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ CARDINAL - ] ] ] ] ].


; num-adj-lex := single-rel-lex-item & basic-icons-lex-item &
; """
; This is the main type for basic Numerals.
; They have [HEAD num]. And the special head-feature [CARDINAL +].

; Their semantics is somewhat special, using CARG in a similar way as named relations.

; We want: the ARG0 of the think it will specify over (SPEC) to be the same as ARG1 on the relation it introduces.
; [FIXME]  LOOK WHY USING THIS ONE, THE ARG0 and ARG1 is links
; """
;   [ SYNSEM [ PAREN -,
;              PUNCTUATED -,
; 	     LOCAL [ CAT [ VAL [ COMPS < >,
; 				 SUBJ < >,
; 				 SPR < >,
; 				 SPEC < [ LOCAL.CONT.HOOK.INDEX #arg1 ] > ],
; 			   HEAD num & [ CARDINAL +,
; 					MOD < > ] ],
; 		     CONT [ HOOK [ LTOP #lbl, 
; 				   INDEX #index ],
; 			    RELS <! #rel !>,
; 			    HCONS <! !> ] ],
; 	     NON-LOCAL.SLASH 0-dlist,
; 	     LKEYS.KEYREL card-relation & #rel & [ LBL #lbl,
; 						   ARG0 #index,
; 						   ARG1 #arg1 ] ] ].



subj-drop-only-verb-lex := subj-drop-verb-lex & no-obj-drop-verb-lex & basic-icons-lex-item.

obj-drop-only-verb-lex := obj-drop-verb-lex & no-subj-drop-verb-lex & basic-icons-lex-item.

subj-obj-drop-verb-lex := subj-drop-verb-lex & obj-drop-verb-lex & basic-icons-lex-item.

no-drop-verb-lex := no-subj-drop-verb-lex & no-obj-drop-verb-lex & basic-icons-lex-item.


de-super-lex := basic-one-arg &
"""DE takes a COMP and modifies a noun. Its position is after its COMP.
POSTCOMP is a feature to be used on head to indicate the COMP's position is after the head.
POSTHEAD - means as a modifier, it always appear before the head noun.

added MODIFIABLE + so we have more say about where this can apply.  
"""
  [ SYNSEM [ POSTCOMP +,
             PUNCTUATED -,
	     LOCAL.CAT [ POSTHEAD -,
                         HEAD postp &
	                      [ MOD < [ BARE bool,
                                        LOCAL intersective-mod &
                                              [ CAT [ HEAD noun & [ MODIFIABLE + ],
                                                      VAL.COMPS < > ] ] ] > ],
			    VAL [ SPR < >,
                                  SPEC < >,
			          COMPS < synsem  & [ LOCAL.CAT.MC + ] > ] ] ] ].

de-assoc-lex := de-super-lex & adposition-lex &
"""
This a supertype of the Associative DE. It will be further defined for 
NP-NP association and CLAUSE-NP association.

ZZF/FB 29-2-2016: associative phrase should precede specifiers in NP
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD postp-assoc & 
                                [ MOD < [ BARE -,
                                        LOCAL [ CONT.HOOK [ LTOP #ltop,
                                                          INDEX #ind ],
                                                CAT.VAL.SPR olist ]  ] > ],
			   VAL.COMPS < #comps >,
                           POSTHEAD - ],
                      CONT.HOOK.LTOP #ltop ],
             LKEYS.KEYREL.ARG1 #ind ],
    ARG-ST <  #comps &
               [ LOCAL [ CAT [ HEAD +nv,
                               VAL [ SPR < >,
                                     SUBJ < >,
                                     COMPS < > ] ],
                         CONT.HOOK.INDEX.SF prop ],
                 NON-LOCAL.SLASH 0-dlist,
                 OPT - ]  > ].

de-assoc-n-lex := de-assoc-lex &
"""
Associative DE combining two noun phrases.
"""
  [ SYNSEM.LOCAL.CAT.HEAD postp-assoc-n,
    ARG-ST < [ LOCAL.CAT.HEAD noun ] > ].

de-assoc-v-lex := de-assoc-lex &
"""
Associative DE with a clause, modifying a noun. 
"""
  [ SYNSEM.LOCAL.CAT.HEAD postp-assoc-v,
    ARG-ST < [ LOCAL.CAT.HEAD verb ] > ].


de-comp-lex := de-super-lex & raise-sem-lex-item & no-icons-lex-item & norm-zero-arg &
"""
Complementizer DE, used in relative clauses. 
The modified noun is the missing argument in the relative clause.

ZZF 2015-9-30: subj restriction of the v/adj to stop spurious parses 
ZZF 2016-2-21: DE does not take subj

It does say that it's COMPS [NON-LOCAL.SLASH 1-dlist], which means that it must be something 
on the slash. So it's not clear why it allows opt-subj-decl  in relative clauses. This is only happening to adjectives, which means SLASH is being left compatible with SLASHED things in adjectives.
"""
  [ SYNSEM [ PAREN -,
             LOCAL [ CAT [ HEAD postp-comp &
                                [  MOD < [ LOCAL.CONT.HOOK [ INDEX #slash,
                                                             LTOP #ltop ] ] > ] ,
                           VAL [ COMPS < [ LOCAL [ CAT [ HEAD +vj & [ COP - ],
                                                         VAL [ SUBJ < > ] ] ],
                                           NON-LOCAL.SLASH 1-dlist & <!
                                               [ CAT [ HEAD noun,
                                                       VAL.SPR < > ],
                                                 CONT.HOOK [ INDEX #slash,
                                                             LTOP #ltop ] ]
                                               !> ] >,
                                 SUBJ < > ] ] ],
              NON-LOCAL [ SLASH <! !>,
                          REL <! !>,
                          QUE <! !> ] ] ].


;;FB & ZZF 2015-10-28 nominalizing DE,
;; creating empty noun (NONCOMP +), in lexicon 的_nom_n gives "generic_n_rel".
;; ZZF 2016-3-16 (POSTCOMP +) as COMPS is before DE
;no longer needed, using de_comp -> 0-nom-p 
;de-nominalizer-lex := no-icons-lex-item & norm-sem-lex-item &
;  [ SYNSEM [ PAREN -,
;             PUNCTUATED -,
;             POSTCOMP +,
;	     LOCAL [ CAT [ HEAD noun & [MOD <> ],
;                           NONCOMP +,
; 			   VAL [ COMPS < [ LOCAL [ CAT [ HEAD +vj,
; 							 MC +-or--, 
;                                                          VAL [ SUBJ < > ] ] ],
; 					   NON-LOCAL [ SLASH 1-dlist &
;                                                              <! [ CONT.HOOK.INDEX #ind ] !> ] ] >,
; 				 SUBJ < >,
; 				 SPEC < >,
; 				 SPR < > ] ], 
; 		     CONT.HOOK.INDEX #ind ],
; 	     NON-LOCAL non-local ] ].



;============================================================================
; ADPOSITIONS, PREPOSITIONS & POSTPOSITIONS
;============================================================================

adposition-lex := basic-adposition-lex & no-hcons-lex-item &
"""
"""
  [ SYNSEM [ PAREN -,
             PUNCTUATED -,
	     LOCAL.CONT [ HOOK [ LTOP #ltop,
				 INDEX #index ],
			  RELS <! #rel !> ],
	     LKEYS.KEYREL #rel & [ LBL #ltop,
			           ARG0 #index ] ] ].

prep-lex := adposition-lex & 
"""
[POSTCOMP -] is the definition of PRE-positions (I come before my COMPS).

But why does it look like it has 2 things in the ARG-ST?
It should only have 1 think (NOUN) in COMPs, right? What is the first NOUN then?
"""
  [ SYNSEM [ POSTCOMP -,
	     LOCAL.CAT [ HEAD prep,
			 VAL [ SPR < >,
			       COMPS < #comps > ] ] ],
    ARG-ST < [ LOCAL.CAT.HEAD noun ],
	     #comps &
	     [ LOCAL.CAT [ VAL [ SPR < >,
				 COMPS < > ] ],
               OPT - ] > ].

prep-no-mod-lex := prep-lex & 
"""
no-mod ??? (No modification)

If MOD < >, then it means it can't act through MODIFICATION rules.
This takes a noun SUBJ + a noun COMP?
Are these supposed to be predicative prepositions of some sort?

There are 3 preps inheriting from here:
在 >>>>>>>>>> commented out 
为 (for e.g. someone)
由 (by/through, e.g. a method)

她 为 房间
她 由 房间
(which I think are not good prepositional sentences) do parse
 为  has a verb on its own (to become).
Given that ZAI is now a verb (I didn't do it) and these two are probably bad,
it's likely we're not using this prepositional type at all.
"""
  [ SYNSEM [ LOCAL.CAT [ HEAD.MOD < >,
             	         VAL [ SUBJ < [ LOCAL [ CAT [ HEAD noun, 
                                                      VAL.SPR < > ],
                                                CONT.HOOK.INDEX #arg1 ] ] >,
                               COMPS < [ LOCAL.CAT.HEAD noun ] > ] ],
             LKEYS.KEYREL.ARG1 #arg1 ] ].

prep-mod-lex := prep-lex & 
"""
linking ARG1 to XARG as well, which can be used in other places to refer to INDEX of what it modifies.

This is the parent type of two other types: prep-n-mod-lex  AND  prep-v-mod-lex
No letypes inherit directly from this.

It basically says I am going to modify something that is of HEAD verb.
Must have fully satisfied COMPS.

It links the index of its MOD value with its own XARG and of its ARG1. (Is this how modification works ???)
"""
  [ SYNSEM [ LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective-mod &
					    [ CAT [ HEAD verb,
						    VAL.COMPS < > ],
					      CONT.HOOK [ LTOP #ltop,
							  INDEX #ind ] ] ] >,
		     CONT.HOOK.LTOP #ltop,
		     CONT.HOOK.XARG #ind ],
	     LKEYS.KEYREL.ARG1 #ind ] ].

prep-n-mod-lex := prep-mod-lex & 
"""
In letypes this says it's supposed to modify NPs... but:
[FIXME][FCB] Why does this specify that the HEAD of the SUBJ of what I modify is a NOUN? 
It should probably be:
HEAD.MOD < [ LOCAL.CAT.HEAD noun ] >  ???
Lik this, this prep can only modify things that have SUBJ.

There are currently more than 170 prepositions that inherit from this type.

"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD noun ] > ] >,
                       POSTHEAD -,
                       VAL [ COMPS < [ LOCAL.CAT.HEAD noun ] >,
                             SUBJ < > ] ] ].

prep-v-mod-lex := prep-mod-lex &
"""

There are only 3 prepositions that inherit from this type: 
lex-base.tdl:1124:和_p := p_-_v-mod_le &     <<<<<<< listed under conjunction!!!
lexicon.tdl:13788:关于_p_2 := p_-_v-mod_le &
lexicon.tdl:68785:犹如_p_1 := p_-_v-mod_le &
"""
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS < [ LOCAL.CAT.HEAD verb ] >,
                       POSTHEAD - ] ].




;;Below is for locative marker zai4
;; SSH 2015-04-16: Now it is regarded as a semantically empty
;; item. (similarly to 'by' in English passives).

basic-loc-lex := raise-sem-lex-item & no-icons-lex-item &
  [ SYNSEM [ PAREN -,
             PUNCTUATED -,
	     LOCAL [ CAT [ HEAD prep & [ MOD #mod ], 
			   VAL.COMPS < phr-synsem & [ LOCAL [ CAT [ HEAD postp & [ MOD #mod ],
								    VAL.COMPS <> ],
							      CONT.HOOK [ LTOP #ltop,
									  INDEX #ind,
									  ICONS-KEY.IARG1 #clause ] ],
						      NON-LOCAL.SLASH <! !> ] > ],
		     CONT.HOOK [ LTOP #ltop,
				 INDEX #ind,
				 CLAUSE-KEY #clause ] ] ] ].

prep-vmod-lex := adposition-lex &
  [ SYNSEM[LOCAL.CAT [ HEAD prep & [ MOD <[ LOCAL intersective-mod &
                                                  [ CONT.HOOK.INDEX #ind ] ] > ],
               VAL [ SPR < >,
                 COMPS < #comps >,
                 SUBJ < > ] ],
       NON-LOCAL.SLASH <!!>,
       LKEYS.KEYREL [ARG1 #ind,
             ARG2 #ind2]],
    ARG-ST <  [ LOCAL.CAT.HEAD noun ],
           #comps & phr-synsem &
            [ LOCAL[CAT [ VAL [ SPR < >,
                    COMPS < > ],
                  HEAD noun ] ,
                CONT.HOOK.INDEX #ind2],
              NON-LOCAL.SLASH <!!>,
              OPT - ] > ].
; `from'
prep-vmod-pre-lex := prep-vmod-lex &
  [ SYNSEM.LOCAL.CAT.POSTHEAD - ].


;; The following type is for locative-markers such as bian4 and mian4 
;; SSH & ZZF 2015-04-15 commented out loc-mark
;; SSH 2015-04-16: 里_p, etc.  
basic-postp-lex := adposition-lex &
"""
POSTCOMP + says that it takes a complement to its left. The restrictions on the ARG-ST say that this complement must be fully specified, not lacking complements and be a noun.

[FIXME] I want to understand what is happening with MOD and ARG-ST (seems to have 2 things?).
I modify something intersectively, it's a saturated verb (VP). The index of VP is the same as the index of my ARG1 -- this is just to make semantics properly link.
And the think that is my COMP is the arg 2 this po

"""
  [ SYNSEM [ POSTCOMP +,
	     LOCAL [ CAT [ HEAD postp & 
				[ MOD < [ LOCAL intersective-mod &
						[ CAT [ HEAD verb,
							VAL.COMPS < > ],
						  CONT.HOOK [ LTOP #ltop,
							      INDEX #ind1 ] ] ] > ],
			   POSTHEAD -,
			   VAL [ SPR < >,
				 COMPS < #comp >,
				 SUBJ < > ] ],
                     CONT.HOOK [ LTOP #ltop ] ],
	     LKEYS.KEYREL [ ARG1 #ind1,
			    ARG2 #ind2 ] ],
    ARG-ST < [ ],
	     #comp & 
	     [ LOCAL [ CAT [ VAL [ SPR < >,
				   COMPS < >,
				   SUBJ < > ],
			     HEAD noun ],
		       CONT.HOOK.INDEX #ind2 ],
	       OPT - ] > ].


;============================================================================
;============================================================================



;;; Lexical rule types for auxiliary verbs

v_aux_ell-lex-rule  := same-head-lex-rule & constant-lex-rule &
"""
We want to preserve the auxiliary status of sentences like 他 会 (he is able to) /  他 可以 (he is allowed to)  /  他 应该 (he must to)  where it is assumed that some elided verb exists. This is preferable to having multiple lexical entries for the auxiliary when there is complement dropping. 

This lexical rule allows this by pumping auxiliaries to no longer need complements (see DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [ ] >); and by fixing the ARGs and QEQ links between the auxiliary verb and an introduced ellipsis_v_rel.

<ex> 他 会 。
<nex> 他 会 唱歌 。
<nex> 他 告诉 。


[FIXME] It would be nice to block this from going through 'vp1-top-coord' (and similar), this is generating a bit of ambiguity.
"""
		       same-subj-lex-rule &
		       same-spr-lex-rule &
		       same-spec-lex-rule &
		       same-non-local-lex-rule &
		       same-modified-lex-rule &
		       same-posthead-lex-rule &
		       same-light-lex-rule &
		       same-hc-light-lex-rule &
		       same-ctxt-lex-rule &
		       same-cont-lex-rule &
		       same-agr-lex-rule & 
  [ SYNSEM.LOCAL [ CAT [ HEAD verb &
				[ AUX + ], 
			   VAL [ COMPS < > ], 
			   MKG #mkg  ],
		   CONT.HOOK.INDEX.E.ASPECT non-aspect ],
    DTR  [ SYNSEM [ LOCAL [ CAT [ VAL [ COMPS < [ ] > ], 
				  MKG #mkg  ],
			    CONT [ HOOK [ XARG #subj ],   ;;; subject of the aux_v links to ARG1 of ellipsis 
				   HCONS <!  [ LARG #ellipsis_index ] !> ] ] ] ],  ;;; link the aux verb QEQ LARG to the LBL of the ellipsis_v_rel 
    C-CONT [ HCONS <! !>,
	     ICONS <! !>,
	     RELS <! arg1-relation & event-relation & 
		   [ LBL  #ellipsis_index,
		     PRED ellipsis_v_rel,
		     ARG1 #subj ] !> ] ].



        
;;; Lexical rule types for aspect




_v_aspect-lex-rule := add-only-no-ccont-rule & infl-lex-rule &
 [ DTR verb-lex ].

_perf_aspect-lex-rule := _v_aspect-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT perfective,
    DTR.ALTS.LE-PFV +].

;; SSH 2014-09-19: 着 is a durative aspect marker.
dur_aspect-lex-rule := _v_aspect-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT durative ].

exp_aspect-lex-rule := _v_aspect-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT experiential ].


;;ZZF 2015-10-2 to stop combining with degree adverb not working; & [ MOD <> ] [ SPR < >, SPEC < > ], 

redup-lex-rule :=  same-non-local-lex-rule &
		   same-modified-lex-rule &
		   same-light-lex-rule &
		   same-ctxt-lex-rule &
		   same-cont-lex-rule &
		   same-agr-lex-rule & 
                   infl-lex-rule &
"""
This rule applies to both adjectives and verbs. And, because of this, some VALENCE constraints (e.g., on the SPR) cannot be decided at this level. 
We leave the VALENCE to be determined by head-specific rules that inherit from this. 
"""
  [ SYNSEM [ ASPECTED -,
	     LOCAL [ CAT [ MC luk,
			   HEAD #head, 
			   MKG #mkg, 
			   HC-LIGHT #light, 
			   POSTHEAD #posthead ],
		     CONT.HOOK.INDEX.E.ASPECT non-aspect ] ],
    DTR  [ SYNSEM [ BOUND -,
		    LOCAL [ CAT [ HEAD #head & [ CHAR.LENGTH one-or-two ], 
				  MKG #mkg, 
				  HC-LIGHT #light, 
				  POSTHEAD #posthead ],
			    CONT.HOOK [ LTOP #ltop,
					INDEX #index ] ] ] ],
    C-CONT [ HCONS <! !>, 
	     ICONS <! !>,
	     RELS <! arg1-relation & event-relation & 
		   [ LBL #ltop,
		     PRED redup_x_rel,
		     ARG1 #index ] !> ] ].


redup-verb-lex-rule :=  redup-lex-rule &
"""
For reduplicated verbs, we are currently transferring the same valency values. 
For the time being, we don't know of any valence-changing constraints imposed by verbal reduplication.
<ex> 你 看看 。
<ex> 我 吃吃 。
<ex> 你 看 看 。
<ex> 我 吃 吃 。
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD verb, 
			   VAL [ SUBJ #subj,
				 COMPS #comps,
				 SPR #spr,
				 SPEC #spec] ] ] ],
    DTR [ SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
				       COMPS #comps,
				       SPR #spr,
				       SPEC #spec] ] ] ] ] ].

redup-adj-lex-rule :=  redup-lex-rule &
"""
For reduplicated adjectives, we need to constrain the SPR of the reduplicated form. 
In ZHONG, degree adverbs (e.g. 很, 非常, etc) attach to the adjective through specifier-head rules. However, in their reduplicated form, adjectives cannot take degree adverbs.
All adjectives expect exactly one such degree modifier (i.e. SPR < [ ] >), while all reduplicated forms now expect zero (i.e. SPR < >).
<ex> 他 高高 。
<ex> 他 高 高 。
<nex> 他 很 高高 。
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD adj, 
			   VAL [ SUBJ #subj,
				 COMPS #comps,
				 SPR < >,
				 SPEC #spec] ] ] ],
    DTR [ SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
				       COMPS #comps,
				       SPR < [ ] >,
				       SPEC #spec] ] ] ] ] ].



;redup-lex-dtr := word-or-lexrule. 

;; SSH 2015-04-30: reduplication of verbs
tentative-lex-rule := add-only-no-rels-hcons-rule & no-ccont-lex-rule &
 [ SYNSEM [ ASPECTED +,
	    LOCAL [ CAT [ MC luk,
			  HEAD #head, 
			  VAL #val, 
			  MKG #mkg, 
			  HC-LIGHT #light, 
			  POSTHEAD #posthead ],
		    CONT.HOOK.INDEX.E.ASPECT tentative ] ],
   DTR tentative-lex-dtr & [ SYNSEM [ BOUND -,
				       LOCAL.CAT [ HEAD #head & [ CHAR.LENGTH one-or-two ], 
						   VAL #val, 
						   MKG #mkg, 
						   HC-LIGHT #light, 
						   POSTHEAD #posthead ] ] ] ].

tent-perf-lex-rule := tentative-lex-rule &
 [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT tent-and-perf ]. 

tentative-lex-dtr := word-or-lexrule. 


;;ZZF 2016-11-30 for A-not-A patterns captured in vanilla.rpp

anota-lex-rule :=  same-modified-lex-rule &
		   same-light-lex-rule &
		   same-ctxt-lex-rule &
		   same-cont-lex-rule &
		   same-agr-lex-rule & 
                   infl-lex-rule & no-rels-hcons-lex-rule &
 [ SYNSEM [ ASPECTED -,
	    LOCAL [ CAT [ MC luk,
			  HEAD #head, 
			  VAL #val, 
			  MKG #mkg, 
			  HC-LIGHT #light, 
			  POSTHEAD #posthead ],
		    CONT.HOOK.INDEX.E.ASPECT non-aspect ],
            NON-LOCAL [ QUE <! #index !>,
                        SLASH #slash,
                        REL #rel ] ],
   DTR word-or-lexrule & [ SYNSEM [ BOUND -,
				  LOCAL [ CAT [ HEAD #head & 
                                                     [ CHAR.LENGTH one-or-two,
                                                       MOD < >,
                                                       MODIFIABLE - ], 
					        VAL #val, 
					        MKG #mkg, 
				                HC-LIGHT #light, 
					        POSTHEAD #posthead ],
                                          CONT.HOOK.INDEX #index ],
                                  NON-LOCAL [ SLASH #slash,
                                              REL #rel ] ] ]
].

 


;;; Relation for trigger rules for semantically empty lexical entries

never_unify_rel := predsort.


;;The below is for the suffix manner adverb forming de 

;; SSH 2014-12-09: 张三 不停 地 叫
;; [adj] is changed as [+vj] / [MC na-or--] is added.
;; SSH 2014-12-19: 狗 [轻轻 地] 叫 了
;; [SUBJ < [] > ] is deleted, and +vj is changed to +vjr.
adv_affix_form_lex := raise-sem-lex-item & basic-icons-lex-item &
"""
Added SUBJ <[ ]> on the complement to block sentences such as: (他 很 高兴) 地 唱歌; Removed SPR < > from the complement because we want to accept both bare adjectives, such as 他 很 高兴 地 唱歌 and adjectives with degree modifiers 他 高兴 地 唱歌; SPR < > will enforce adjectives to be degree modified;
"""
  [ SYNSEM.LOCAL.CAT [ HEAD adv &
			    [ MOD < [ LOCAL [ CAT [ HEAD verb,
						    VAL [ SUBJ <[ ]>,
							  COMPS < > ] ],
					      CONT.HOOK.INDEX #ind ] ] > ],
		       VAL [ SUBJ < > ] ],
    ARG-ST < [ LOCAL [ CAT [ HEAD +vjr & [ PRD + ],
			     MC na-or--,
			     VAL [ COMPS < >,
				   SUBJ <[ ]> ] ],
		       CONT.HOOK.XARG #ind ] ] > ].


;; ZZF 2016-11-29 adv+di changing adv to be di's comp, as spr is reserved for degree specifier
; POSTCOMP+ as it's after its comp
adv_suffix_form_lex := adv_affix_form_lex &
  [ SYNSEM [ BOUND +,
             POSTCOMP +,
	     LOCAL.CAT [ POSTHEAD -,
                         HEAD.MOD < [ LOCAL intersective-mod ] >,
			 VAL [ SPR < >,   
			       COMPS < #comp > ] ] ],
    ARG-ST < #comp > ].

adv_prefix_form_lex := adv_affix_form_lex &
  [ SYNSEM.LOCAL.CAT [ POSTHEAD +,
		       VAL [ SPR <>,
			     COMPS < #comps > ] ],
    ARG-ST < #comps > ].


;; SSH 2014-09-04: A constant-lex-rule for non-aspecttual sentences
;; (e.g. 张三 叫). A sentence without any aspect markers should not be
;; paraphrased into sentences with such markers.
aspect-lex-rule := const-cat-change-only-lex-rule & 
 [ SYNSEM [ ASPECTED -,
	    BOUND #bound,
	    LOCAL.CAT [ MC luk,
		      HEAD #head, 
		      VAL #val, 
		      MKG #mkg, 
		      HC-LIGHT #light, 
		      POSTHEAD #posthead ] ],
   DTR aspect-rule-dtr & [ SYNSEM [ BOUND #bound,
				    LOCAL.CAT [ HEAD #head, 
						VAL #val, 
						MKG #mkg, 
						HC-LIGHT #light, 
						POSTHEAD #posthead ] ] ],
   C-CONT [ RELS <! !>, HCONS <! !>, ICONS <! !> ] ].

;;15-2-2016 ZZF SSH FB stop using MC for controlling overgeneration, which will be done in SEM-I
aspect-rule-dtr := word-or-lexrule.
;;& [ SYNSEM.LOCAL.CAT.MC na ]


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; MATRIX REDEFINITION - intersective adjectives must not have their index
;; identified with that of the noun they modify
;;basic-mod-adj-lex := basic-adjective-lex & raise-index-mod-lex-item.
basic-mod-adj-lex := basic-adjective-lex & norm-ltop-lex-item.



;; SSH 2014-08-22 - lexeme-to-lexeme-rule is not used in matrix.tdl
;; any longer. infl-lex-rule or constant-lex-rule now works for it.

;; WWJ 2015-02-17 - Value of daughter's CHAR.length should be passed up
;; This provide the constrain that prevents a-not-a-contracted-adv-lex from acting on it.

attr-to-pred-adj-lex-rule := pred-adj-lex & constant-lex-rule &
[ SYNSEM [ LKEYS.KEYREL.PRED #pred, 
  		   LOCAL.CAT.HEAD.CHAR.LENGTH #charlength ],
  DTR attr-adj-lex & [ SYNSEM [ LKEYS.KEYREL.PRED #pred, 
                                LOCAL.CAT.HEAD.CHAR.LENGTH #charlength  ] ] ].

;; DPF 2011-06-03 - Adverb complement may need to be restricted to aspect
;; markers, but note that "cat old de very" is okay, and likewise for other
;; normally pre-head (degree) adverbs ("cat old de unbearable").  Hypothesis 
;; is that this `de' simply combines with a pre-head (degree) adverb or
;; degree-clause ("(so) angry that we can hardly imagine")
;; to produce a post-head adv.
;;

;; WWJ 2015-02-17 - Value of daughter's CHAR.length should be passed up to the head of the phrase
;; This provides the constrain that prevents a-not-a-contracted-adv-lex from acting on it.

attr-to-pred-adj-aspect-lex-rule := basic-pred-adj-lex & constant-lex-rule &
[ SYNSEM [ LKEYS.KEYREL.PRED #pred,
	   LOCAL [ CAT [ HEAD [ MOD < >,
                            CHAR.LENGTH #charlength ],  
			 VAL [ SPR < [ LOCAL [ CAT.HEAD adv,
					       CONT.HOOK #hook ] ] >,
			       COMPS < [ LOCAL 
					       [ CAT [ HEAD adv &
							    [ MOD < [ LOCAL.CAT.VAL.SUBJ < > ] > ],
						       POSTHEAD + ],
						 CONT.HOOK #hook ],
					 OPT - ] > ] ],
		   CONT.HOOK #hook ] ],
  DTR attr-adj-lex &
	 [ SYNSEM [ LKEYS.KEYREL.PRED #pred,
                LOCAL.CAT.HEAD.CHAR.LENGTH #charlength ] ] ].

vp-aux-ellipsis-lex-rule := aux-lex & constant-lex-rule & c-cont-1 &  
  [ SYNSEM [ LOCAL.CAT [ HEAD #head,
             VAL [ SUBJ #subj & < [ NON-LOCAL.SLASH #slash ] >,
                   SPR #spr,
                   COMPS < > ] ],
         NON-LOCAL.SLASH #slash,
         LKEYS #lkeys ],
    DTR v_aux-aux-lex &
     [ SYNSEM [ LOCAL [ CAT [ HEAD #head,
                  VAL [ SUBJ #subj,
                    SPR #spr,
                    COMPS < [ LOCAL.CONT.HOOK 
                              [ LTOP #ltop,
                                XARG #xarg ] ] > ]],
                CONT.HOOK #hook ],
            LKEYS #lkeys ] ],
    C-CONT [ HOOK #hook,
             ICONS <! !>,
             RELS <! [ LBL #ltop,
                       PRED ellipsis_v_rel,
                       ARG1 #xarg ] !> ] ].





; comma := punct.

;; SSH 2015-04-20: [NON-LOCAL.SLASH 0-dlist] on COMPS is deleted for robust parsing. 
;; SSH 2015-04-27: +vjrpc => +nvjrpc (because of allowing frag + punctuation: e.g. 张三 。)
;; punctuations don't have QUE. "?" will introduce ques directly, so question-phrase is not necessary
punctuation := nonque-item &
  [ SYNSEM [ PUNCTUATED +,
	     LOCAL [ CAT [ HEAD punct,
			   VAL [ SUBJ <>,
				 SPR <>,
				 COMPS < [ PUNCTUATED na-or--,
					   LOCAL [ CAT [ MC +,			    
							 HEAD +nvjrpc,
							 VAL [ SUBJ <>, COMPS <> ] ],
						   CONT.HOOK.INDEX.SF #sf ] ] > ],
			   POSTHEAD + ],
		     CONT [ HOOK.INDEX.SF #sf,
			    RELS <! !>, HCONS <! !>, ICONS <! !> ] ] ] ].

punctuation-end := punctuation &
  [ SYNSEM [ L-PERIPH +,
	     R-PERIPH + ] ].


;;; ques-mark := punctuation-end &
ques-mark := punctuation-end &
"""
There was an ambiguity problem with question-phrase, since the question mark was able to attach before or after question-phrase. 
To block this, we created this type where we require that ques-mark's complement's  NON-LOCAL.QUE is 0-dlist (i.e. already went through question-phrase).
"""
  [SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.SF ques,
				 NON-LOCAL.QUE 0-dlist ]> ].


symbol := single-rel-lex-item & basic-icons-lex-item & nonque-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD punct,
			   VAL [ SUBJ <>, 
				 SPR <>,
				 SPEC <>,
				 COMPS <  [ LOCAL.CAT.HEAD +nvjrp ] > ] ],
		     CONT [ HOOK [ LTOP #lbl, 
				   INDEX #index ],
			    RELS <! #rel !>,
			    HCONS <! !> ] ],
	     NON-LOCAL.SLASH 0-dlist,
             PUNCTUATED +,
	     LKEYS.KEYREL symbol-relation & #rel & [ LBL #lbl,
						     ARG1 #index ] ] ].
	     
comma-or-colon := symbol  &
  [ SYNSEM [ LOCAL [ CAT [ POSTHEAD + ] ] ] ].
  
paren := symbol & 
  [ SYNSEM.PAREN + ].

lparen := paren &
  [ SYNSEM [ LOCAL [ CAT [ POSTHEAD - ] ] ] ].

;;ZZF 2016-12-06 parenthesis strategy: always combine with rparen first
rparen := paren &
  [ SYNSEM [ LOCAL [ CAT [ VAL.COMPS < [ PAREN na-or-- ] >,
			   POSTHEAD + ] ] ] ].
bullet := symbol &
  [ SYNSEM [ L-PERIPH +,
	     R-PERIPH +,
	     LOCAL [ CAT [ VAL.COMPS < [ LOCAL.CAT [ HEAD +nvj,
						     VAL [ SUBJ <>, COMPS <> ] ] ] >,
			   POSTHEAD - ] ] ] ].

